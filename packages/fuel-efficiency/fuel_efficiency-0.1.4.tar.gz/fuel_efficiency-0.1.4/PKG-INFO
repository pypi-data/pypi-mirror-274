Metadata-Version: 2.1
Name: fuel-efficiency
Version: 0.1.4
Summary: Fuel efficiency challenge test
License: Proprietary
Author: Guilherme Lima
Author-email: guimarotto@gmail.com
Requires-Python: >=3.12,<4.0
Classifier: Development Status :: 5 - Production/Stable
Classifier: Environment :: Console
Classifier: License :: Other/Proprietary License
Classifier: Natural Language :: Portuguese (Brazilian)
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.12
Classifier: Programming Language :: Python :: 3.11
Classifier: Topic :: Software Development
Project-URL: Bug Tracker, https://github.com/gllima/fuel-efficiencyissues
Project-URL: Código, https://github.com/gllima/fuel-efficiency
Description-Content-Type: text/markdown

# Fuel Efficiency
[![CI](https://github.com/gllima/fuel-efficiency/actions/workflows/pipeline.yaml/badge.svg)](https://github.com/gllima/fuel-efficiency/actions/workflows/pipeline.yaml)
[![codecov](https://codecov.io/gh/gllima/fuel-efficiency/graph/badge.svg?token=YA2PDIU40R)](https://codecov.io/gh/gllima/fuel-efficiency)
[![PyPI version](https://badge.fury.io/py/notas-musicais.svg)](https://badge.fury.io/py/notas-musicais)


## Overview
Fuel efficiency is a project that implements Dijkstra and A* algorithms in order to calculate the shortest path in a 
grid that can be formed by nodes with different weights that influence on fuel consumption. 

## Solution Description
In order to solve the fuel consumption problem, `entities` and `algorithms` was developed.

### Entities

The `entities` folder contains the implementation for `Node` and `position`. Where `position` is a `dataclass`
implementation por a position in a 2D grid, with x-axis and y-axis. `Node` is also a `dataclass` that represents a node 
on a grid and have a `weight` and a `position` and can represent various terrains. 
Each terrain is a `node` subclass and has a weight that determines the difficulty of the terrain that reflects on the fuel consumption.

- `DownHill`, weight = 0.5
- `Valley`, weight = 1
- `UpHill`, weight = 2
- `Plateau`, weight = 1

Each of these `node` subclasses plays a role in the simulation of a vehicle moving through different terrains, 
affecting its fuel efficiency.

### Algorithms

The `algorithms` folder includes files that describe algorithms for pathfinding. 
These algorithms will be used to determine the most efficient path through the grid considering the different terrains. 
The developed algorithms are:

- `PathFinding`, that is an Abstract Base Class (ABC) for a PathFindingStrategy. 
- `Dijkstra`, that is an implementation of a PathFindingStrategy that implements the Dijkstra's Algorithm for a finding 
the shortest path between a starting and ending points, allowing movements on vertical, horizontal and diagonal directions.
- `A*`, that is an implementation of a PathFindingStrategy that implements the A* Algorithm for a finding 
the shortest path between a starting and ending points, allowing only movements on vertical and horizontal directions.


## Packaging and dependency Management
To ease the development `Poetry` was used to perform packaging and dependency management and `taskipy` was used to automate some commands.
You can check the available `taskipy` commands by typing `task -l`

```bash
task -l                                                                                                                                                                                                                                                                                                                                                                                      ✔  fuel-efficiency-py3.12  
lint                blue --check --diff . && isort --check --diff .
docs                mkdocs serve
pre_test            task lint
test                pytest -s -x --cov=fuel_efficiency -vv
test_entities       pytest tests/test_entities.py -s -x -vv
test_entities_raise pytest tests/test_entities_raise.py -s -x -vv
test_algorithms     pytest tests/test_algorithms.py -s -x -vv
post_test           coverage html
build               poetry build
publish             poetry publish
```

## Testing

To guarantee a good test coverage on the code and improve its quality a suite of tests is provided. The tests can be found in the `tests` folder.
You can run all the tests and the coverage of them by typing `task test`, also each of the test files has a specific command to run alone, that you can find by typing `task -l`

## Coverage
After executing `task test` that runs all tests, a coverage report is generated, and it is available on a `htmlcov/index.html` file on a local repository.
Also, the solution coverage is available on codecov that is an all-in-one coverage reporting solution, it is updated on each repository push.

You can access the coverage report here: https://codecov.io/gh/gllima/fuel-efficiency

# CI/CD Implementation

A Continuous Integration and Continuous Deployment (CI/CD) pipeline using GitHub Actions was set. This pipeline automate the testing and deployment of the solution.

## Workflow Steps
1. **Clone repository files**:  Upon each push or pull request to the main branch, after creating the `ubuntu-latest` container, the repository is cloned.
2. **Install python on the container**:  Then `python3.12` is installed.
3. **Install poetry**:  After that, `Poetry` is installed to deal with our dependencies.
4. **Install the dependencies**:  So,`Poetry` install all the project dependencies.
5. **Run tests with pytest**: Execute tests using pytest. This ensures that all new changes are verified before deployment.
6. **Upload the code coverage to codecov**:  The code coverage report is uploaded to codecov.
7. **Builds a Package**: If the tests pass, builds a Python package, that it is ready for deployment to PyPI.
8. **Publish the package on Pypi**: After the package is built publishes to Pypi project. 
9. **Creates a Release**: After successful deployment to PyPI, creates a downloadable artifact of the package.


