'''
This file contains the decorators that create the view classes for the tables
of the database.
'''
# pylint: disable=protected-access

from __future__ import annotations
from typing import Literal, NamedTuple, Any, TYPE_CHECKING
from pathlib import Path
from abc import ABC
import sqlite3

_SUPPORTED_TYPES = {
    Path: "Path",
    str: "TEXT",
    int: "INTEGER",
}

class _TableConnection(NamedTuple):
    columns: tuple[str, str]
    '''The pair of collumn names (this table column, other table column).'''

    is_pk: bool
    '''Whether the connection is referencing a primary key of other table.'''

class WeakTableConnection(NamedTuple):
    '''
    Used for type annotation in the 'dbtableview' decorator for
    weak_connects_to argument.
    '''
    this_table_column_name: str
    other_table_name: str
    other_table_column_name: str

RELATION_MAP: dict[str, dict[str, _TableConnection]] = {}
'''
The RELATION_MAP is a map of all the relations between the tables. It is
generated by the decorators while creating the database tables. It's used to
build the easy queries.
'''

WRAPPER_CLASSES: dict[str, type] = {}
'''
The WRAPPER_CLASSES maps all of the wrapper classes annotaded with the
'dbtableview' decorator to their names (the names are the keys of the dict).
It's used in the easy queries to determine which wrapper class to use as a
result of the query.
'''

def validate_weak_connections():
    '''
    Runs at the end of importing the sqlite_bedrock_packs package. It validates the
    connections between the tables. It's used to make sure that the weak
    connections are correct (which can't be checked in the decorator while they
    are being created).
    '''
    # TODO - maybe also check that the types of the columns are the same
    for this_table, v in RELATION_MAP.items():
        for other_table, v2 in v.items():
            if v2.is_pk:
                continue  # No need to check primary key connections
            if other_table not in RELATION_MAP:
                raise AssertionError(
                    f"Invalid connection: {this_table} -> {other_table}:"
                    f"The {other_table} table doesn't exist"
                )
    return True  # Returns true for the assert statement

def add_reverse_connections():
    '''
    Runs at the end of importing the sqlite_bedrock_packs package. It adds the
    reverse connections to the relation map.
    '''
    for this_table, v in RELATION_MAP.items():
        for other_table, v2 in v.items():
            if this_table not in RELATION_MAP[other_table]:
                RELATION_MAP[other_table][this_table] = _TableConnection(
                    columns=(v2.columns[1], v2.columns[0]),
                    is_pk=v[other_table].is_pk
                )


class AbstractDBView(ABC):
    '''
    This abstract class is used in the PYI files as a parent of all of
    the wrapped classes.
    '''
    if TYPE_CHECKING:
        __name__: str
        build_script: str

class _DbTableView:
    '''
    Used for dbtableview decorator. For more information see the decorator
    documentation.
    '''
    def __init__(
            self,
            cls: type,
            properties: dict[str, tuple[type,Literal["NOT NULL", ""]]],
            enum_properties: dict[str, list[str]],
            connects_to: list[str],
            weak_connects_to: list[WeakTableConnection]):
        # VALIDATE THE PARAMETERS
        # Properties
        if not isinstance(properties, dict):  # pyright: ignore[reportUnnecessaryIsInstance]
            raise TypeError("The 'properties' parameter must be a dict")
        for name, value in properties.items():
            if not isinstance(name, str):  # pyright: ignore[reportUnnecessaryIsInstance]
                raise TypeError(
                    "The keys of the 'properties' parameter must be strings")
            if not name.isidentifier():
                raise ValueError(
                    f"The key '{name}' of the 'properties' parameter is not a "
                    "valid identifier")
            if not isinstance(value, tuple):  # pyright: ignore[reportUnnecessaryIsInstance]
                raise TypeError(
                    "The values of the 'properties' parameter must be tuples")
            if len(value) != 2:
                raise ValueError(
                    "The values of the 'properties' parameter must be tuples "
                    "of length 2")
            if not isinstance(value[0], type):
                raise TypeError(
                    "The first value of the tuples of the 'properties' "
                    "parameter must be a type")
            if value[0] not in _SUPPORTED_TYPES:
                raise ValueError(
                    f"The type {value[0]} is not supported by the decorator")
        # Enum properties
        if not isinstance(enum_properties, dict):  # pyright: ignore[reportUnnecessaryIsInstance]
            raise TypeError("The 'enum_properties' parameter must be a dict")
        for name, value in enum_properties.items():
            if not isinstance(name, str):  # pyright: ignore[reportUnnecessaryIsInstance]
                raise TypeError(
                    "The keys of the 'enum_properties' parameter must be "
                    "strings")
            if not name.isidentifier():
                raise ValueError(
                    f"The key '{name}' of the 'enum_properties' parameter is "
                    "not a valid identifier")
            if not isinstance(value, list):  # pyright: ignore[reportUnnecessaryIsInstance]
                raise TypeError(
                    "The values of the 'enum_properties' parameter must be "
                    "lists")
            for item in value:
                if not isinstance(item, str):  # pyright: ignore[reportUnnecessaryIsInstance]
                    raise TypeError(
                        "The values of the lists of the 'enum_properties' "
                        "parameter must be strings")
        # Connects to
        if not isinstance(connects_to, list):  # pyright: ignore[reportUnnecessaryIsInstance]
            raise TypeError(
                "The 'connects_to' parameter must be a list of strings")
        for name in connects_to:
            if not isinstance(name, str):  # pyright: ignore[reportUnnecessaryIsInstance]
                raise TypeError(
                    "The 'connects_to' parameter must be a list of strings")
            if not name.isidentifier():
                raise ValueError(
                    f"The value '{name}' of the 'connects_to' parameter is not "
                    "a valid identifier")
        # Weak connects to
        if not isinstance(weak_connects_to, list):  # pyright: ignore[reportUnnecessaryIsInstance]
            raise TypeError(
                "The 'weak_connects_to' parameter must be a list of tuples")
        for item in weak_connects_to:
            if not isinstance(item, tuple):  # pyright: ignore[reportUnnecessaryIsInstance]
                raise TypeError(
                    "The 'weak_connects_to' parameter must be a list of "
                    "tuples")
            if len(item) != 3:
                raise ValueError(
                    "The tuples of the 'weak_connects_to' parameter must be "
                    "of length 3")
            if not isinstance(item[0], str):  # pyright: ignore[reportUnnecessaryIsInstance]
                raise TypeError(
                    "The first value of the tuples of the 'weak_connects_to' "
                    "parameter must be a string")
            if not item[0].isidentifier():
                raise ValueError(
                    f"The first value '{item[0]}' of the tuples of the "
                    "'weak_connects_to' parameter is not a valid identifier")
            if not isinstance(item[1], str):  # pyright: ignore[reportUnnecessaryIsInstance]
                raise TypeError(
                    "The second value of the tuples of the "
                    "'weak_connects_to' parameter must be a string")
            if not item[1].isidentifier():
                raise ValueError(
                    f"The second value '{item[1]}' of the tuples of the "
                    "'weak_connects_to' parameter is not a valid identifier")
            if not isinstance(item[2], str):  # pyright: ignore[reportUnnecessaryIsInstance]
                raise TypeError(
                    "The third value of the tuples of the "
                    "'weak_connects_to' parameter must be a string")
            if not item[2].isidentifier():
                raise ValueError(
                    f"The third value '{item[2]}' of the tuples of the "
                    "'weak_connects_to' parameter is not a valid identifier")
        # SAVE THE PARAMETERS
        self.cls = cls
        self.properties = properties
        self.enum_properties = enum_properties
        self.connects_to = connects_to
        # REGISTER THE CLASS IN THE RELATION MAP
        if self.cls.__name__ in RELATION_MAP:
            raise ValueError(
                f"The class {self.cls.__name__} is already registered in the "
                "relation map")
        this_table = {}
        RELATION_MAP[self.cls.__name__] = this_table
        # Add the connections to the relation map
        for name in self.connects_to:
            if name not in RELATION_MAP:
                raise ValueError(
                    f"Trying to connect {self.cls.__name__} to {name} but "
                    f"{name} is not registered in the relation map."
                )
            this_table[name] = _TableConnection(
                columns=(f"{name}_fk", f"{name}_pk"),
                is_pk=True
            )
        # Add the weak connections to the relation map
        for this_table_column, other_table, other_table_column in (
                weak_connects_to):
            this_table[other_table] = _TableConnection(
                columns=(this_table_column, other_table_column),
                is_pk=False
            )

    def assert_valid(self):
        '''
        Checks if provided parameters are valid:
        - The original class can't define properties reserved for new
            functionality.
        - The original class can't define properties that are defined in the
            decorator as the names of the properties of the table.
        '''
        # Check if the original function doesn't define properties that are
        # required for the decorated class to work
        for reserved_name in [
                "query_result", "_query_result_cache", "build_script"]:
            if reserved_name in self.cls.__dict__:
                raise ValueError(
                    "Unable to decorate class because it already defines "
                    "a property reserved for the decorated class result.\n"
                    f"Property name: {reserved_name}"
                )
        # Check if the original function doesn't define a property that is
        # required for accesing the properties of the table in the database
        for name in self.connects_to:
            reserved_name = f"{name}_fk"
            if reserved_name in self.cls.__dict__:
                raise ValueError(
                    "Unable to decorate class because it already defines "
                    "a property defined in the 'connect_to' property of the "
                    "decorator.\n"
                    f"Property name: {reserved_name}"
                )
        for name in self.properties:
            if name in self.cls.__dict__:
                raise ValueError(
                    "Unable to decorate class because it already defines "
                    "a property defined in the 'properties' property of "
                    "the decorator.\n"
                    f"Property name: {name}"
                )
        for name in self.enum_properties:
            if name in self.cls.__dict__:
                raise ValueError(
                    "Unable to decorate class because it already defines "
                    "a property defined in the 'enum_properties' property of "
                    "the decorator.\n"
                    f"Property name: {name}"
                )

    def generate_build_script(self) -> str:
        '''
        Creates the SQL script that creates the table in the database.
        '''
        build_script_lines: list[str] = []
        # If there are enum properties, build the enum tables
        for name, values in self.enum_properties.items():
            table_name = f"{self.cls.__name__}{name.capitalize()}Enum"
            build_script_lines.extend([
                f"CREATE TABLE {table_name} (",
                "    value TEXT PRIMARY KEY",
                ");"
            ])
            for value in values:
                build_script_lines.append(
                    f"INSERT INTO {table_name} (value) VALUES ('{value}');")
        # Start defining the main table
        build_script_lines.append(f"CREATE TABLE {self.cls.__name__} (")
        # Internal lines of the class are later indented and connected with commans
        build_class_internal: list[str] = []
        # Primary key
        build_class_internal.append(
            f"{self.cls.__name__}_pk INTEGER PRIMARY KEY AUTOINCREMENT")
        # Foreign keys definitions
        for table_name in self.connects_to:
            build_class_internal.append(f"{table_name}_fk INTEGER NOT NULL")
        # Enum properties definitions
        for property_name in self.enum_properties:
            build_class_internal.append(f"{property_name} TEXT NOT NULL")
        # The rest of the properties
        for property_name, (type_, nullable) in self.properties.items():
            build_class_internal.append(
                f"{property_name} {_SUPPORTED_TYPES[type_]} "
                f"{nullable}".rstrip())
        # Mark the foreign keys properties as foreign keys
        for table_name in self.connects_to:
            build_class_internal.append(
                f"FOREIGN KEY ({table_name}_fk) "
                f"REFERENCES {table_name} ({table_name}_pk) "
                "ON DELETE CASCADE")
        # Mark the enum properties as foreign keys
        for property_name in self.enum_properties:
            table_name = f"{self.cls.__name__}{property_name.capitalize()}Enum"
            build_class_internal.append(
                f"FOREIGN KEY ({property_name}) "
                f"REFERENCES {table_name} (value)")
        # Build the script
        build_script_lines.append(
            ",\n".join("    " + line for line in build_class_internal))
        build_script_lines.append(");")
        # Add the index lines on the foreign keys
        for name in self.connects_to:
            build_script_lines.append(
                f"CREATE INDEX {self.cls.__name__}_{name}_fk "
                f"ON {self.cls.__name__} ({name}_fk);")
        build_script = "\n".join(build_script_lines) + "\n"
        return build_script

    def generate_init(self):
        '''
        Creates the init method of the class.
        '''
        def init(self_: Any, connection: sqlite3.Connection, id_: int):
            self_._connection = connection
            self_._id = id_
            self_._query_result_cache = None
        init.__qualname__ = f"{self.cls.__name__}.__init__"
        return init

    def generate_query_result(self):
        '''
        Creates the query_result method of the class.
        '''
        _query_result_columns = ", ".join(
            [f"{name}_fk" for name in self.connects_to] +
            list(self.properties) +
            list(self.enum_properties)
        )

        def query_result(self_: Any):
            if self_._query_result_cache is None:
                self_._query_result_cache = self_.connection.execute(
                    f"SELECT {_query_result_columns} "
                    f"FROM {self.cls.__name__} "
                    f"WHERE {self.cls.__name__}_pk = ?",
                    (self_.id,)
                ).fetchone()
            return self_._query_result_cache
        query_result.__qualname__ = f"{self.cls.__name__}.query_result"
        return query_result

    def generate_properties(self):
        '''
        Creates the @property decorated properties of the class.
        '''
        properties: dict[str, Any] = {}
        # FOREIGN KEYS
        for i, name in enumerate(self.connects_to):
            @property
            def fk_prop_method(self: Any, /, _i: int=i) -> int:
                return self.query_result()[_i]
            properties[f"{name}_fk"] = fk_prop_method
        # REGULAR PROPERTIES
        for i, (name, (_, _)) in enumerate(
                self.properties.items(),
                start=len(self.connects_to)):
            @property
            def prop_method(self: Any, /, _i: int=i) -> Any:  # pyright: ignore
                return self.query_result()[_i]
            properties[name] = prop_method
        # ENUM PROPERTIES
        for i, name in enumerate(
                self.enum_properties,
                start=len(self.connects_to) + len(self.properties)):
            @property
            def enum_prop_method(self: Any, /, _i: int = i) -> str:
                return self.query_result()[_i]
            properties[name] = enum_prop_method
        # ID and CONNECTION
        @property
        def id_(self: Any) -> int:
            return self._id
        properties["id"] = id_

        @property
        def connection(self: Any) -> sqlite3.Connection:
            return self._connection
        properties["connection"] = connection
        return properties

    def generate_annotations(self):
        '''
        Creates the __annotations__ attribute of the class.
        '''
        annotations_ = {}
        try:
            annotations_ = self.cls.__annotations__
        except AttributeError:
            pass
        # Add the annotations of the properties
        for name, (type_, _) in self.properties.items():
            annotations_[name] = type_
        # Add the annotations of the foreign keys
        for name in self.connects_to:
            annotations_[f"{name}_fk"] = int
        # Add the annotations of the enum properties
        for name in self.enum_properties:
            annotations_[name] = str
        # Add the annotations of the id and connection
        annotations_["id"] = int
        annotations_["connection"] = sqlite3.Connection
        # Add the annotations of the query_result method
        annotations_["query_result"] = "Callable[[], tuple[Any, ...]]"
        # Add the annotations of the build_script method
        annotations_["build_script"] = str
        return annotations_

    def __call__(self) -> AbstractDBView:
        # VALIDATE THE PARAMETERS
        self.assert_valid()

        # BUILD THE SCRIPT
        build_script = self.generate_build_script()

        # BUILD THE CLASS
        init = self.generate_init()
        query_result = self.generate_query_result()
        properties = self.generate_properties()
        annotations_ = self.generate_annotations()

        # CREATE THE TYPE OBJECT
        result = type(
            self.cls.__name__,
            (AbstractDBView,),
            {
                "__init__": init,
                "__doc__": f'{self.cls.__name__}(connection, id)',
                "__slots__": ("_id", "_connection", "_query_result_cache"),
                "__module__": "sqlite_bedrock_packs.views",
                "__annotations__": annotations_,
                "query_result": query_result,
                "build_script": build_script
            } | properties | {
                # Add the attributes of the original class
                name: value
                for name, value in list(self.cls.__dict__.items())
                if not (name.startswith("__") and name.endswith("__"))
            }
        )
        # REGISTER IN THE WRAPPER_CLASSES MAP
        WRAPPER_CLASSES[self.cls.__name__] = result

        return result  # type: ignore

def dbtableview(
        properties: dict[str, tuple[type, Literal["NOT NULL", ""]]] | None = None,
        enum_properties: dict[str, list[str]] | None = None,
        connects_to: list[str] | None = None,
        weak_connects_to: list[WeakTableConnection] | None = None,
):
    '''
    The "dbtableview" is a decorator that turns a class into a read-only view
    of a row in a table in the database. It also registers the class in the
    relation map and adds some attributes to the class.

    This decorator uses additional parameters, so in order to use it, you have
    to use the parentesis even if you don't pass any values, e.g.:

    .. code-block:: python
        @dbtable()
        class MyClassName: ...

    The decorator adds following properties properties:

    The constructor method takes 2 parameters - the Connection object to the
    database, and the ID of the row in the table.

    Other parameters are not stored directly in the class and are accessed by
    querying the database. Accessing any of the properties runs a query, which
    gets all of the properties of the row at once. The results are cached to
    provide the data to any subsequent calls to the properties. Note that the
    cache is not invalidated if the data in the database changes.

    Running the query without accessing the properties can be forced by calling
    the 'query_result' method.

    The class has a class attribute called 'build_script' that contains the SQL
    script to create the table.

    :param properties: A dictionary that defines the properties of the table.
        The keys are the names of the properties to be added to the class and
        SQL table. The values define the type of the property and whether it is
        nullable. The first value is the type, the second value is either
        "NOT NULL" or an empty string.
    :param enum_properties: A dictionary that defines the properties of the
        table that are enums. In the database, the enums are stored as separate
        tables that use their values as primary keys. The creation and
        population of the enum tables is added at the top of the
        'build_script'. The table that references the enum table has a property
        with a constraint that it can only contain values from the enum table.
    :param connects_to: A list of names of the other previously defined tables
        that this table has a foreign key to. The names of the foreign keys are
        generated by the name of the table and the suffix '_fk'. If the
        referenced table is not defined yet, the decorator will raise an
        exception.
    :param weak_connects_to: A list of connections to the other tables in the
        database. The tables don't need to be defined at the time of the
        decorator call. The weak connections don't have any effect on the
        database schema, but they are used to generate the "easy queries".
        Unlike the "connects_to" connections, the weak connections can connect
        any row in the table to any other row in other table (it's not just
        a foreign key-primary key connection).
    '''
    if properties is None:
        properties = {}
    if enum_properties is None:
        enum_properties = {}
    if connects_to is None:
        connects_to = []
    if weak_connects_to is None:
        weak_connects_to = []
    def decorator(cls: type):
        return _DbTableView(
            cls, properties, enum_properties, connects_to, weak_connects_to)()
    return decorator
