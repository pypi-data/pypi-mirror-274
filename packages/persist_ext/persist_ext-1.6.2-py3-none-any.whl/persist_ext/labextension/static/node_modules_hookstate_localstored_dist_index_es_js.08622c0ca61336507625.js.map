{"version":3,"file":"node_modules_hookstate_localstored_dist_index_es_js.08622c0ca61336507625.js","mappings":";;;;;;;;;;;;;AAUM,SAAU,WAAW,CAAO,OAIjC;IACG,OAAO;AACH,YAAI,GAAW,CAAC;AAChB,YAAI,UAA4C,CAAC;AACjD,YAAI,YAAqD,CAAC;AAC1D,YAAI,WAAwB;AAC5B,YAAI,aAAa,GAA0B,QAAO,KAAP,eAAO,KAAP,yBAAO,CAAE,MAAM,KAAI,YAAY,CAAC;QAE3E,OAAO;AACH,kBAAM,EAAE,UAAC,KAAK,EAAE,gBAAgB;gBAC5B,WAAW,GAAG,KAAK,CAAC;gBACpB,IAAI,QAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,GAAG,MAAK,SAAS,EAAE;AAC5B,wBAAI,gBAAgB,CAAC,YAAY,CAAC,KAAK,SAAS,EAAE;AAC9C,8BAAM,KAAK,CAAC,yCAAyC,CAAC;AACzD;oBACD,GAAG,GAAG,gBAAgB,CAAC,YAAY,CAAC,CAAC,KAAK,CAAC;AAC9C;AAAM;AACH,uBAAG,GAAG,OAAO,CAAC,GAAG;AACpB;AACD,oBAAI,gBAAgB,CAAC,WAAW,CAAC,KAAK,SAAS,EAAE;AAC7C,8BAAU,GAAG,gBAAgB,CAAC,WAAW,CAAC;AAC7C;AAAM;oBACH,UAAU,GAAG,UAAC,CAAC,EAAK,qBAAM,aAAI,CAAC,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC,CAAC,CAAxC,EAAwC,CAA9C,EAA8C;AACrE;AACD,oBAAI,gBAAgB,CAAC,aAAa,CAAC,KAAK,SAAS,EAAE;oBAC/C,YAAY,GAAG,gBAAgB,CAAC,aAAa,CAAC,CAAC,KAAK,CAAC;AACxD;AAAM;oBACH,YAAY,GAAG,UAAC,CAAC,EAAK,mBAAC,CAAC,IAAK,QAAC,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAApB,EAAoB,CAA3B,EAA2B;AACpD;;;gBAID,IAAM,QAAQ,GAAG,aAAa,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;gBAC5C,OAAO,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC,mBAAS;AACpC,wBAAI,SAAS,EAAE;;wBAEX,YAAY,CAAC,KAAK,CAAC,CAAC,SAAS,CAAC,CAAC;AAClC;AAAM,6BAAI,OAAO,KAAP,eAAO,uBAAP,OAAO,CAAE,WAAW,EAAE;AAC7B,+BAAO,CAAC,WAAW,EAAE,CAAC,IAAI,CAAC,WAAC;AACxB,iCAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;AACjB,yBAAC,CAAC,CAAC;AACN;AACL,iBAAC,CAAC,CAAC;aACN;YACD,KAAK,EAAE,UAAC,CAAC;gBACL,IAAI,CAAC,CAAC,QAAQ,IAAI,CAAC,CAAC,KAAK,KAAK,SAAS,EAAE;oBACrC,IAAM,QAAQ,GAAG,aAAa,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;oBAC/C,OAAO,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC,eAAS,CAAC,CAAC;AAC7C;AAAM;;;;AAIH,wBAAM,QAAQ,GAAG,aAAa,CAAC,OAAO,CAAC,GAAG,EAAE,UAAU,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC;oBACvE,OAAO,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC,eAAS,CAAC,CAAC;AAC7C;aACJ;SACJ;AACL,KAAC;AACL","sources":["webpack://persist_ext/./node_modules/@hookstate/localstored/src/localstorage.ts"],"sourcesContent":["import { ExtensionFactory, State } from '@hookstate/core';\r\n\r\nexport interface StoreEngine {\r\n    getItem: (key: string) => Promise<string | null> | string;\r\n    setItem: (key: string, value: string) => Promise<void> | void;\r\n    removeItem: (key: string) => Promise<void> | void;\r\n}\r\n\r\nexport interface LocalStored { }\r\n\r\nexport function localstored<S, E>(options?: {\r\n    key?: string,\r\n    engine?: StoreEngine,\r\n    initializer?: () => Promise<S>\r\n}): ExtensionFactory<S, E, LocalStored> {\r\n    return () => {\r\n        let key: string;\r\n        let serializer: (s: State<S, E>) => () => string;\r\n        let deserializer: (s: State<S, E>) => (v: string) => void;\r\n        let stateAtRoot: State<S, E>\r\n        let storageEngine: StoreEngine | Storage = options?.engine || localStorage;\r\n\r\n        return {\r\n            onInit: (state, extensionMethods) => {\r\n                stateAtRoot = state;\r\n                if (options?.key === undefined) {\r\n                    if (extensionMethods['identifier'] === undefined) {\r\n                        throw Error('State is missing Identifiable extension')\r\n                    }\r\n                    key = extensionMethods['identifier'](state)\r\n                } else {\r\n                    key = options.key\r\n                }\r\n                if (extensionMethods['serialize'] !== undefined) {\r\n                    serializer = extensionMethods['serialize']\r\n                } else {\r\n                    serializer = (s) => () => JSON.stringify(s.get({ noproxy: true }))\r\n                }\r\n                if (extensionMethods['deserialize'] !== undefined) {\r\n                    deserializer = extensionMethods['deserialize'](state)\r\n                } else {\r\n                    deserializer = (s) => (v) => s.set(JSON.parse(v))\r\n                }\r\n\r\n                // here it is synchronous, but most storages would be async\r\n                // this is supported too, as the state.set can be really set asynchronously\r\n                const response = storageEngine.getItem(key);\r\n                Promise.resolve(response).then(persisted => {\r\n                    if (persisted) {\r\n                        // persisted state exists\r\n                        deserializer(state)(persisted); // this one sets the state value as well\r\n                    } else if (options?.initializer) {\r\n                        options.initializer().then(s => {\r\n                            state.set(s);\r\n                        });\r\n                    }\r\n                });\r\n            },\r\n            onSet: (s) => {\r\n                if (s.promised || s.error !== undefined) {\r\n                    const response = storageEngine.removeItem(key);\r\n                    Promise.resolve(response).then(() => { });\r\n                } else {\r\n                    // save the entire state from the root\r\n                    // smarter implementations could implement partial state saving,\r\n                    // which would save only the nested state set (parameter `s` in onSet)\r\n                    const response = storageEngine.setItem(key, serializer(stateAtRoot)());\r\n                    Promise.resolve(response).then(() => { });\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n"],"names":[],"sourceRoot":""}