{"ast":null,"code":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { Vector } from '../vector';\nimport { MapRow, StructRow } from '../vector/row';\nimport { compareArrayLike } from '../util/buffer';\nimport { BigInt, BigIntAvailable } from './compat';\n/** @ignore */\nexport function clampIndex(source, index, then) {\n  const length = source.length;\n  const adjust = index > -1 ? index : length + index % length;\n  return then ? then(source, adjust) : adjust;\n}\n/** @ignore */\nlet tmp;\n/** @ignore */\nexport function clampRange(source, begin, end, then) {\n  // Adjust args similar to Array.prototype.slice. Normalize begin/end to\n  // clamp between 0 and length, and wrap around on negative indices, e.g.\n  // slice(-1, 5) or slice(5, -1)\n  let {\n    length: len = 0\n  } = source;\n  let lhs = typeof begin !== 'number' ? 0 : begin;\n  let rhs = typeof end !== 'number' ? len : end;\n  // wrap around on negative start/end positions\n  lhs < 0 && (lhs = (lhs % len + len) % len);\n  rhs < 0 && (rhs = (rhs % len + len) % len);\n  // ensure lhs <= rhs\n  rhs < lhs && (tmp = lhs, lhs = rhs, rhs = tmp);\n  // ensure rhs <= length\n  rhs > len && (rhs = len);\n  return then ? then(source, lhs, rhs) : [lhs, rhs];\n}\nconst big0 = BigIntAvailable ? BigInt(0) : 0;\nconst isNaNFast = value => value !== value;\n/** @ignore */\nexport function createElementComparator(search) {\n  let typeofSearch = typeof search;\n  // Compare primitives\n  if (typeofSearch !== 'object' || search === null) {\n    // Compare NaN\n    if (isNaNFast(search)) {\n      return isNaNFast;\n    }\n    return typeofSearch !== 'bigint' ? value => value === search : value => big0 + value === search;\n  }\n  // Compare Dates\n  if (search instanceof Date) {\n    const valueOfSearch = search.valueOf();\n    return value => value instanceof Date ? value.valueOf() === valueOfSearch : false;\n  }\n  // Compare TypedArrays\n  if (ArrayBuffer.isView(search)) {\n    return value => value ? compareArrayLike(search, value) : false;\n  }\n  // Compare Maps and Rows\n  if (search instanceof Map) {\n    return creatMapComparator(search);\n  }\n  // Compare Array-likes\n  if (Array.isArray(search)) {\n    return createArrayLikeComparator(search);\n  }\n  // Compare Vectors\n  if (search instanceof Vector) {\n    return createVectorComparator(search);\n  }\n  // Compare non-empty Objects\n  return createObjectComparator(search);\n}\n/** @ignore */\nfunction createArrayLikeComparator(lhs) {\n  const comparators = [];\n  for (let i = -1, n = lhs.length; ++i < n;) {\n    comparators[i] = createElementComparator(lhs[i]);\n  }\n  return createSubElementsComparator(comparators);\n}\n/** @ignore */\nfunction creatMapComparator(lhs) {\n  let i = -1;\n  const comparators = [];\n  lhs.forEach(v => comparators[++i] = createElementComparator(v));\n  return createSubElementsComparator(comparators);\n}\n/** @ignore */\nfunction createVectorComparator(lhs) {\n  const comparators = [];\n  for (let i = -1, n = lhs.length; ++i < n;) {\n    comparators[i] = createElementComparator(lhs.get(i));\n  }\n  return createSubElementsComparator(comparators);\n}\n/** @ignore */\nfunction createObjectComparator(lhs) {\n  const keys = Object.keys(lhs);\n  // Only compare non-empty Objects\n  if (keys.length === 0) {\n    return () => false;\n  }\n  const comparators = [];\n  for (let i = -1, n = keys.length; ++i < n;) {\n    comparators[i] = createElementComparator(lhs[keys[i]]);\n  }\n  return createSubElementsComparator(comparators, keys);\n}\nfunction createSubElementsComparator(comparators, keys) {\n  return rhs => {\n    if (!rhs || typeof rhs !== 'object') {\n      return false;\n    }\n    switch (rhs.constructor) {\n      case Array:\n        return compareArray(comparators, rhs);\n      case Map:\n      case MapRow:\n      case StructRow:\n        return compareObject(comparators, rhs, rhs.keys());\n      case Object:\n      case undefined:\n        // support `Object.create(null)` objects\n        return compareObject(comparators, rhs, keys || Object.keys(rhs));\n    }\n    return rhs instanceof Vector ? compareVector(comparators, rhs) : false;\n  };\n}\nfunction compareArray(comparators, arr) {\n  const n = comparators.length;\n  if (arr.length !== n) {\n    return false;\n  }\n  for (let i = -1; ++i < n;) {\n    if (!comparators[i](arr[i])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction compareVector(comparators, vec) {\n  const n = comparators.length;\n  if (vec.length !== n) {\n    return false;\n  }\n  for (let i = -1; ++i < n;) {\n    if (!comparators[i](vec.get(i))) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction compareObject(comparators, obj, keys) {\n  const lKeyItr = keys[Symbol.iterator]();\n  const rKeyItr = obj instanceof Map ? obj.keys() : Object.keys(obj)[Symbol.iterator]();\n  const rValItr = obj instanceof Map ? obj.values() : Object.values(obj)[Symbol.iterator]();\n  let i = 0;\n  let n = comparators.length;\n  let rVal = rValItr.next();\n  let lKey = lKeyItr.next();\n  let rKey = rKeyItr.next();\n  for (; i < n && !lKey.done && !rKey.done && !rVal.done; ++i, lKey = lKeyItr.next(), rKey = rKeyItr.next(), rVal = rValItr.next()) {\n    if (lKey.value !== rKey.value || !comparators[i](rVal.value)) {\n      break;\n    }\n  }\n  if (i === n && lKey.done && rKey.done && rVal.done) {\n    return true;\n  }\n  lKeyItr.return && lKeyItr.return();\n  rKeyItr.return && rKeyItr.return();\n  rValItr.return && rValItr.return();\n  return false;\n}","map":{"version":3,"sources":["util/vector.ts"],"names":[],"mappings":"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","sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { Vector } from '../vector';\nimport { MapRow, StructRow } from '../vector/row';\nimport { compareArrayLike } from '../util/buffer';\nimport { BigInt, BigIntAvailable } from './compat';\n\n/** @ignore */\ntype RangeLike = { length: number; stride?: number };\n/** @ignore */\ntype ClampThen<T extends RangeLike> = (source: T, index: number) => any;\n/** @ignore */\ntype ClampRangeThen<T extends RangeLike> = (source: T, offset: number, length: number) => any;\n\nexport function clampIndex<T extends RangeLike>(source: T, index: number): number;\nexport function clampIndex<T extends RangeLike, N extends ClampThen<T> = ClampThen<T>>(source: T, index: number, then: N): ReturnType<N>;\n/** @ignore */\nexport function clampIndex<T extends RangeLike, N extends ClampThen<T> = ClampThen<T>>(source: T, index: number, then?: N) {\n    const length = source.length;\n    const adjust = index > -1 ? index : (length + (index % length));\n    return then ? then(source, adjust) : adjust;\n}\n\n/** @ignore */\nlet tmp: number;\nexport function clampRange<T extends RangeLike>(source: T, begin: number | undefined, end: number | undefined): [number, number];\nexport function clampRange<T extends RangeLike, N extends ClampRangeThen<T> = ClampRangeThen<T>>(source: T, begin: number | undefined, end: number | undefined, then: N): ReturnType<N>;\n/** @ignore */\nexport function clampRange<T extends RangeLike, N extends ClampRangeThen<T> = ClampRangeThen<T>>(source: T, begin: number | undefined, end: number | undefined, then?: N) {\n\n    // Adjust args similar to Array.prototype.slice. Normalize begin/end to\n    // clamp between 0 and length, and wrap around on negative indices, e.g.\n    // slice(-1, 5) or slice(5, -1)\n    let { length: len = 0 } = source;\n    let lhs = typeof begin !== 'number' ? 0 : begin;\n    let rhs = typeof end !== 'number' ? len : end;\n    // wrap around on negative start/end positions\n    (lhs < 0) && (lhs = ((lhs % len) + len) % len);\n    (rhs < 0) && (rhs = ((rhs % len) + len) % len);\n    // ensure lhs <= rhs\n    (rhs < lhs) && (tmp = lhs, lhs = rhs, rhs = tmp);\n     // ensure rhs <= length\n    (rhs > len) && (rhs = len);\n\n    return then ? then(source, lhs, rhs) : [lhs, rhs];\n}\n\nconst big0 = BigIntAvailable ? BigInt(0) : 0;\nconst isNaNFast = (value: any) => value !== value;\n\n/** @ignore */\nexport function createElementComparator(search: any) {\n    let typeofSearch = typeof search;\n    // Compare primitives\n    if (typeofSearch !== 'object' || search === null) {\n        // Compare NaN\n        if (isNaNFast(search)) {\n            return isNaNFast;\n        }\n        return typeofSearch !== 'bigint'\n            ? (value: any) => value === search\n            : (value: any) => (big0 + value) === search;\n    }\n    // Compare Dates\n    if (search instanceof Date) {\n        const valueOfSearch = search.valueOf();\n        return (value: any) => value instanceof Date ? (value.valueOf() === valueOfSearch) : false;\n    }\n    // Compare TypedArrays\n    if (ArrayBuffer.isView(search)) {\n        return (value: any) => value ? compareArrayLike(search, value) : false;\n    }\n    // Compare Maps and Rows\n    if (search instanceof Map) { return creatMapComparator(search); }\n    // Compare Array-likes\n    if (Array.isArray(search)) { return createArrayLikeComparator(search); }\n    // Compare Vectors\n    if (search instanceof Vector) { return createVectorComparator(search); }\n    // Compare non-empty Objects\n    return createObjectComparator(search);\n}\n\n/** @ignore */\nfunction createArrayLikeComparator(lhs: ArrayLike<any>) {\n    const comparators = [] as ((x: any) => boolean)[];\n    for (let i = -1, n = lhs.length; ++i < n;) {\n        comparators[i] = createElementComparator(lhs[i]);\n    }\n    return createSubElementsComparator(comparators);\n}\n\n/** @ignore */\nfunction creatMapComparator(lhs: Map<any, any>) {\n    let i = -1;\n    const comparators = [] as ((x: any) => boolean)[];\n    lhs.forEach((v) => comparators[++i] = createElementComparator(v));\n    return createSubElementsComparator(comparators);\n}\n\n/** @ignore */\nfunction createVectorComparator(lhs: Vector<any>) {\n    const comparators = [] as ((x: any) => boolean)[];\n    for (let i = -1, n = lhs.length; ++i < n;) {\n        comparators[i] = createElementComparator(lhs.get(i));\n    }\n    return createSubElementsComparator(comparators);\n}\n\n/** @ignore */\nfunction createObjectComparator(lhs: any) {\n    const keys = Object.keys(lhs);\n    // Only compare non-empty Objects\n    if (keys.length === 0) { return () => false; }\n    const comparators = [] as ((x: any) => boolean)[];\n    for (let i = -1, n = keys.length; ++i < n;) {\n        comparators[i] = createElementComparator(lhs[keys[i]]);\n    }\n    return createSubElementsComparator(comparators, keys);\n}\n\nfunction createSubElementsComparator(comparators: ((x: any) => boolean)[], keys?: Iterable<string>) {\n    return (rhs: any) => {\n        if (!rhs || typeof rhs !== 'object') {\n            return false;\n        }\n        switch (rhs.constructor) {\n            case Array: return compareArray(comparators, rhs);\n            case Map:\n            case MapRow:\n            case StructRow:\n                return compareObject(comparators, rhs, rhs.keys());\n            case Object:\n            case undefined: // support `Object.create(null)` objects\n                return compareObject(comparators, rhs, keys || Object.keys(rhs));\n        }\n        return rhs instanceof Vector ? compareVector(comparators, rhs) : false;\n    };\n}\n\nfunction compareArray(comparators: ((x: any) => boolean)[], arr: any[]) {\n    const n = comparators.length;\n    if (arr.length !== n) { return false; }\n    for (let i = -1; ++i < n;) {\n        if (!(comparators[i](arr[i]))) { return false; }\n    }\n    return true;\n}\n\nfunction compareVector(comparators: ((x: any) => boolean)[], vec: Vector) {\n    const n = comparators.length;\n    if (vec.length !== n) { return false; }\n    for (let i = -1; ++i < n;) {\n        if (!(comparators[i](vec.get(i)))) { return false; }\n    }\n    return true;\n}\n\nfunction compareObject(comparators: ((x: any) => boolean)[], obj: Map<any, any>, keys: Iterable<string>) {\n\n    const lKeyItr = keys[Symbol.iterator]();\n    const rKeyItr = obj instanceof Map ? obj.keys() : Object.keys(obj)[Symbol.iterator]();\n    const rValItr = obj instanceof Map ? obj.values() : Object.values(obj)[Symbol.iterator]();\n\n    let i = 0;\n    let n = comparators.length;\n    let rVal = rValItr.next();\n    let lKey = lKeyItr.next();\n    let rKey = rKeyItr.next();\n\n    for (; i < n && !lKey.done && !rKey.done && !rVal.done;\n         ++i, lKey = lKeyItr.next(), rKey = rKeyItr.next(), rVal = rValItr.next()) {\n        if (lKey.value !== rKey.value || !comparators[i](rVal.value)) {\n            break;\n        }\n    }\n    if (i === n && lKey.done && rKey.done && rVal.done) {\n        return true;\n    }\n    lKeyItr.return && lKeyItr.return();\n    rKeyItr.return && rKeyItr.return();\n    rValItr.return && rValItr.return();\n    return false;\n}\n"]},"metadata":{},"sourceType":"module"}