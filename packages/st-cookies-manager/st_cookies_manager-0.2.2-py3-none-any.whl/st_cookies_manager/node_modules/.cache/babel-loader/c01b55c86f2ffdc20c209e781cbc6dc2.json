{"ast":null,"code":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { MessageHeader } from '../enum';\nimport { flatbuffers } from 'flatbuffers';\nvar ByteBuffer = flatbuffers.ByteBuffer;\nimport { Message } from './metadata/message';\nimport { isFileHandle } from '../util/compat';\nimport { AsyncRandomAccessFile } from '../io/file';\nimport { toUint8Array } from '../util/buffer';\nimport { ByteStream, AsyncByteStream } from '../io/stream';\nimport { ArrowJSON, ITERATOR_DONE } from '../io/interfaces';\n/** @ignore */\nconst invalidMessageType = type => \"Expected \".concat(MessageHeader[type], \" Message in stream, but was null or length 0.\");\n/** @ignore */\nconst nullMessage = type => \"Header pointer of flatbuffer-encoded \".concat(MessageHeader[type], \" Message is null or length 0.\");\n/** @ignore */\nconst invalidMessageMetadata = (expected, actual) => \"Expected to read \".concat(expected, \" metadata bytes, but only read \").concat(actual, \".\");\n/** @ignore */\nconst invalidMessageBodyLength = (expected, actual) => \"Expected to read \".concat(expected, \" bytes for message body, but only read \").concat(actual, \".\");\n/** @ignore */\nexport class MessageReader {\n  constructor(source) {\n    this.source = source instanceof ByteStream ? source : new ByteStream(source);\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n  next() {\n    let r;\n    if ((r = this.readMetadataLength()).done) {\n      return ITERATOR_DONE;\n    }\n    // ARROW-6313: If the first 4 bytes are continuation indicator (-1), read\n    // the next 4 for the 32-bit metadata length. Otherwise, assume this is a\n    // pre-v0.15 message, where the first 4 bytes are the metadata length.\n    if (r.value === -1 && (r = this.readMetadataLength()).done) {\n      return ITERATOR_DONE;\n    }\n    if ((r = this.readMetadata(r.value)).done) {\n      return ITERATOR_DONE;\n    }\n    return r;\n  }\n  throw(value) {\n    return this.source.throw(value);\n  }\n  return(value) {\n    return this.source.return(value);\n  }\n  readMessage(type) {\n    let r;\n    if ((r = this.next()).done) {\n      return null;\n    }\n    if (type != null && r.value.headerType !== type) {\n      throw new Error(invalidMessageType(type));\n    }\n    return r.value;\n  }\n  readMessageBody(bodyLength) {\n    if (bodyLength <= 0) {\n      return new Uint8Array(0);\n    }\n    const buf = toUint8Array(this.source.read(bodyLength));\n    if (buf.byteLength < bodyLength) {\n      throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));\n    }\n    // 1. Work around bugs in fs.ReadStream's internal Buffer pooling, see: https://github.com/nodejs/node/issues/24817\n    // 2. Work around https://github.com/whatwg/streams/blob/0ebe4b042e467d9876d80ae045de3843092ad797/reference-implementation/lib/helpers.js#L126\n    return /* 1. */buf.byteOffset % 8 === 0 && /* 2. */buf.byteOffset + buf.byteLength <= buf.buffer.byteLength ? buf : buf.slice();\n  }\n  readSchema() {\n    let throwIfNull = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const type = MessageHeader.Schema;\n    const message = this.readMessage(type);\n    const schema = message && message.header();\n    if (throwIfNull && !schema) {\n      throw new Error(nullMessage(type));\n    }\n    return schema;\n  }\n  readMetadataLength() {\n    const buf = this.source.read(PADDING);\n    const bb = buf && new ByteBuffer(buf);\n    const len = bb && bb.readInt32(0) || 0;\n    return {\n      done: len === 0,\n      value: len\n    };\n  }\n  readMetadata(metadataLength) {\n    const buf = this.source.read(metadataLength);\n    if (!buf) {\n      return ITERATOR_DONE;\n    }\n    if (buf.byteLength < metadataLength) {\n      throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));\n    }\n    return {\n      done: false,\n      value: Message.decode(buf)\n    };\n  }\n}\n/** @ignore */\nexport class AsyncMessageReader {\n  constructor(source, byteLength) {\n    this.source = source instanceof AsyncByteStream ? source : isFileHandle(source) ? new AsyncRandomAccessFile(source, byteLength) : new AsyncByteStream(source);\n  }\n  [Symbol.asyncIterator]() {\n    return this;\n  }\n  async next() {\n    let r;\n    if ((r = await this.readMetadataLength()).done) {\n      return ITERATOR_DONE;\n    }\n    // ARROW-6313: If the first 4 bytes are continuation indicator (-1), read\n    // the next 4 for the 32-bit metadata length. Otherwise, assume this is a\n    // pre-v0.15 message, where the first 4 bytes are the metadata length.\n    if (r.value === -1 && (r = await this.readMetadataLength()).done) {\n      return ITERATOR_DONE;\n    }\n    if ((r = await this.readMetadata(r.value)).done) {\n      return ITERATOR_DONE;\n    }\n    return r;\n  }\n  async throw(value) {\n    return await this.source.throw(value);\n  }\n  async return(value) {\n    return await this.source.return(value);\n  }\n  async readMessage(type) {\n    let r;\n    if ((r = await this.next()).done) {\n      return null;\n    }\n    if (type != null && r.value.headerType !== type) {\n      throw new Error(invalidMessageType(type));\n    }\n    return r.value;\n  }\n  async readMessageBody(bodyLength) {\n    if (bodyLength <= 0) {\n      return new Uint8Array(0);\n    }\n    const buf = toUint8Array(await this.source.read(bodyLength));\n    if (buf.byteLength < bodyLength) {\n      throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));\n    }\n    // 1. Work around bugs in fs.ReadStream's internal Buffer pooling, see: https://github.com/nodejs/node/issues/24817\n    // 2. Work around https://github.com/whatwg/streams/blob/0ebe4b042e467d9876d80ae045de3843092ad797/reference-implementation/lib/helpers.js#L126\n    return /* 1. */buf.byteOffset % 8 === 0 && /* 2. */buf.byteOffset + buf.byteLength <= buf.buffer.byteLength ? buf : buf.slice();\n  }\n  async readSchema() {\n    let throwIfNull = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const type = MessageHeader.Schema;\n    const message = await this.readMessage(type);\n    const schema = message && message.header();\n    if (throwIfNull && !schema) {\n      throw new Error(nullMessage(type));\n    }\n    return schema;\n  }\n  async readMetadataLength() {\n    const buf = await this.source.read(PADDING);\n    const bb = buf && new ByteBuffer(buf);\n    const len = bb && bb.readInt32(0) || 0;\n    return {\n      done: len === 0,\n      value: len\n    };\n  }\n  async readMetadata(metadataLength) {\n    const buf = await this.source.read(metadataLength);\n    if (!buf) {\n      return ITERATOR_DONE;\n    }\n    if (buf.byteLength < metadataLength) {\n      throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));\n    }\n    return {\n      done: false,\n      value: Message.decode(buf)\n    };\n  }\n}\n/** @ignore */\nexport class JSONMessageReader extends MessageReader {\n  constructor(source) {\n    super(new Uint8Array(0));\n    this._schema = false;\n    this._body = [];\n    this._batchIndex = 0;\n    this._dictionaryIndex = 0;\n    this._json = source instanceof ArrowJSON ? source : new ArrowJSON(source);\n  }\n  next() {\n    const {\n      _json\n    } = this;\n    if (!this._schema) {\n      this._schema = true;\n      const message = Message.fromJSON(_json.schema, MessageHeader.Schema);\n      return {\n        done: false,\n        value: message\n      };\n    }\n    if (this._dictionaryIndex < _json.dictionaries.length) {\n      const batch = _json.dictionaries[this._dictionaryIndex++];\n      this._body = batch['data']['columns'];\n      const message = Message.fromJSON(batch, MessageHeader.DictionaryBatch);\n      return {\n        done: false,\n        value: message\n      };\n    }\n    if (this._batchIndex < _json.batches.length) {\n      const batch = _json.batches[this._batchIndex++];\n      this._body = batch['columns'];\n      const message = Message.fromJSON(batch, MessageHeader.RecordBatch);\n      return {\n        done: false,\n        value: message\n      };\n    }\n    this._body = [];\n    return ITERATOR_DONE;\n  }\n  readMessageBody(_bodyLength) {\n    return flattenDataSources(this._body);\n    function flattenDataSources(xs) {\n      return (xs || []).reduce((buffers, column) => [...buffers, ...(column['VALIDITY'] && [column['VALIDITY']] || []), ...(column['TYPE'] && [column['TYPE']] || []), ...(column['OFFSET'] && [column['OFFSET']] || []), ...(column['DATA'] && [column['DATA']] || []), ...flattenDataSources(column['children'])], []);\n    }\n  }\n  readMessage(type) {\n    let r;\n    if ((r = this.next()).done) {\n      return null;\n    }\n    if (type != null && r.value.headerType !== type) {\n      throw new Error(invalidMessageType(type));\n    }\n    return r.value;\n  }\n  readSchema() {\n    const type = MessageHeader.Schema;\n    const message = this.readMessage(type);\n    const schema = message && message.header();\n    if (!message || !schema) {\n      throw new Error(nullMessage(type));\n    }\n    return schema;\n  }\n}\n/** @ignore */\nexport const PADDING = 4;\n/** @ignore */\nexport const MAGIC_STR = 'ARROW1';\n/** @ignore */\nexport const MAGIC = new Uint8Array(MAGIC_STR.length);\nfor (let i = 0; i < MAGIC_STR.length; i += 1 | 0) {\n  MAGIC[i] = MAGIC_STR.charCodeAt(i);\n}\n/** @ignore */\nexport function checkForMagicArrowString(buffer) {\n  let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  for (let i = -1, n = MAGIC.length; ++i < n;) {\n    if (MAGIC[i] !== buffer[index + i]) {\n      return false;\n    }\n  }\n  return true;\n}\n/** @ignore */\nexport const magicLength = MAGIC.length;\n/** @ignore */\nexport const magicAndPadding = magicLength + PADDING;\n/** @ignore */\nexport const magicX2AndPadding = magicLength * 2 + PADDING;","map":{"version":3,"sources":["ipc/message.ts"],"names":[],"mappings":"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","sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { MessageHeader } from '../enum';\nimport { flatbuffers } from 'flatbuffers';\nimport ByteBuffer = flatbuffers.ByteBuffer;\nimport { Message } from './metadata/message';\nimport { isFileHandle } from '../util/compat';\nimport { AsyncRandomAccessFile } from '../io/file';\nimport { toUint8Array, ArrayBufferViewInput } from '../util/buffer';\nimport { ByteStream, ReadableSource, AsyncByteStream } from '../io/stream';\nimport { ArrowJSON, ArrowJSONLike, ITERATOR_DONE, FileHandle } from '../io/interfaces';\n\n/** @ignore */ const invalidMessageType       = (type: MessageHeader) => `Expected ${MessageHeader[type]} Message in stream, but was null or length 0.`;\n/** @ignore */ const nullMessage              = (type: MessageHeader) => `Header pointer of flatbuffer-encoded ${MessageHeader[type]} Message is null or length 0.`;\n/** @ignore */ const invalidMessageMetadata   = (expected: number, actual: number) => `Expected to read ${expected} metadata bytes, but only read ${actual}.`;\n/** @ignore */ const invalidMessageBodyLength = (expected: number, actual: number) => `Expected to read ${expected} bytes for message body, but only read ${actual}.`;\n\n/** @ignore */\nexport class MessageReader implements IterableIterator<Message> {\n    protected source: ByteStream;\n    constructor(source: ByteStream | ArrayBufferViewInput | Iterable<ArrayBufferViewInput>) {\n        this.source = source instanceof ByteStream ? source : new ByteStream(source);\n    }\n    public [Symbol.iterator](): IterableIterator<Message> { return this as IterableIterator<Message>; }\n    public next(): IteratorResult<Message> {\n        let r;\n        if ((r = this.readMetadataLength()).done) { return ITERATOR_DONE; }\n        // ARROW-6313: If the first 4 bytes are continuation indicator (-1), read\n        // the next 4 for the 32-bit metadata length. Otherwise, assume this is a\n        // pre-v0.15 message, where the first 4 bytes are the metadata length.\n        if ((r.value === -1) &&\n            (r = this.readMetadataLength()).done) { return ITERATOR_DONE; }\n        if ((r = this.readMetadata(r.value)).done) { return ITERATOR_DONE; }\n        return (<any> r) as IteratorResult<Message>;\n    }\n    public throw(value?: any) { return this.source.throw(value); }\n    public return(value?: any) { return this.source.return(value); }\n    public readMessage<T extends MessageHeader>(type?: T | null) {\n        let r: IteratorResult<Message<T>>;\n        if ((r = this.next()).done) { return null; }\n        if ((type != null) && r.value.headerType !== type) {\n            throw new Error(invalidMessageType(type));\n        }\n        return r.value;\n    }\n    public readMessageBody(bodyLength: number): Uint8Array {\n        if (bodyLength <= 0) { return new Uint8Array(0); }\n        const buf = toUint8Array(this.source.read(bodyLength));\n        if (buf.byteLength < bodyLength) {\n            throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));\n        }\n        // 1. Work around bugs in fs.ReadStream's internal Buffer pooling, see: https://github.com/nodejs/node/issues/24817\n        // 2. Work around https://github.com/whatwg/streams/blob/0ebe4b042e467d9876d80ae045de3843092ad797/reference-implementation/lib/helpers.js#L126\n        return /* 1. */ (buf.byteOffset % 8 === 0) &&\n               /* 2. */ (buf.byteOffset + buf.byteLength) <= buf.buffer.byteLength ? buf : buf.slice();\n    }\n    public readSchema(throwIfNull = false) {\n        const type = MessageHeader.Schema;\n        const message = this.readMessage(type);\n        const schema = message && message.header();\n        if (throwIfNull && !schema) {\n            throw new Error(nullMessage(type));\n        }\n        return schema;\n    }\n    protected readMetadataLength(): IteratorResult<number> {\n        const buf = this.source.read(PADDING);\n        const bb = buf && new ByteBuffer(buf);\n        const len = bb && bb.readInt32(0) || 0;\n        return { done: len === 0, value: len };\n    }\n    protected readMetadata(metadataLength: number): IteratorResult<Message> {\n        const buf = this.source.read(metadataLength);\n        if (!buf) { return ITERATOR_DONE; }\n        if (buf.byteLength < metadataLength) {\n            throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));\n        }\n        return { done: false, value: Message.decode(buf) };\n    }\n}\n\n/** @ignore */\nexport class AsyncMessageReader implements AsyncIterableIterator<Message> {\n    protected source: AsyncByteStream;\n    constructor(source: ReadableSource<Uint8Array>);\n    constructor(source: FileHandle, byteLength?: number);\n    constructor(source: any, byteLength?: number) {\n        this.source = source instanceof AsyncByteStream ? source\n            : isFileHandle(source)\n            ? new AsyncRandomAccessFile(source, byteLength!)\n            : new AsyncByteStream(source);\n    }\n    public [Symbol.asyncIterator](): AsyncIterableIterator<Message> { return this as AsyncIterableIterator<Message>; }\n    public async next(): Promise<IteratorResult<Message>> {\n        let r;\n        if ((r = await this.readMetadataLength()).done) { return ITERATOR_DONE; }\n        // ARROW-6313: If the first 4 bytes are continuation indicator (-1), read\n        // the next 4 for the 32-bit metadata length. Otherwise, assume this is a\n        // pre-v0.15 message, where the first 4 bytes are the metadata length.\n        if ((r.value === -1) &&\n            (r = await this.readMetadataLength()).done) { return ITERATOR_DONE; }\n        if ((r = await this.readMetadata(r.value)).done) { return ITERATOR_DONE; }\n        return (<any> r) as IteratorResult<Message>;\n    }\n    public async throw(value?: any) { return await this.source.throw(value); }\n    public async return(value?: any) { return await this.source.return(value); }\n    public async readMessage<T extends MessageHeader>(type?: T | null) {\n        let r: IteratorResult<Message<T>>;\n        if ((r = await this.next()).done) { return null; }\n        if ((type != null) && r.value.headerType !== type) {\n            throw new Error(invalidMessageType(type));\n        }\n        return r.value;\n    }\n    public async readMessageBody(bodyLength: number): Promise<Uint8Array> {\n        if (bodyLength <= 0) { return new Uint8Array(0); }\n        const buf = toUint8Array(await this.source.read(bodyLength));\n        if (buf.byteLength < bodyLength) {\n            throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));\n        }\n        // 1. Work around bugs in fs.ReadStream's internal Buffer pooling, see: https://github.com/nodejs/node/issues/24817\n        // 2. Work around https://github.com/whatwg/streams/blob/0ebe4b042e467d9876d80ae045de3843092ad797/reference-implementation/lib/helpers.js#L126\n        return /* 1. */ (buf.byteOffset % 8 === 0) &&\n               /* 2. */ (buf.byteOffset + buf.byteLength) <= buf.buffer.byteLength ? buf : buf.slice();\n    }\n    public async readSchema(throwIfNull = false) {\n        const type = MessageHeader.Schema;\n        const message = await this.readMessage(type);\n        const schema = message && message.header();\n        if (throwIfNull && !schema) {\n            throw new Error(nullMessage(type));\n        }\n        return schema;\n    }\n    protected async readMetadataLength(): Promise<IteratorResult<number>> {\n        const buf = await this.source.read(PADDING);\n        const bb = buf && new ByteBuffer(buf);\n        const len = bb && bb.readInt32(0) || 0;\n        return { done: len === 0, value: len };\n    }\n    protected async readMetadata(metadataLength: number): Promise<IteratorResult<Message>> {\n        const buf = await this.source.read(metadataLength);\n        if (!buf) { return ITERATOR_DONE; }\n        if (buf.byteLength < metadataLength) {\n            throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));\n        }\n        return { done: false, value: Message.decode(buf) };\n    }\n}\n\n/** @ignore */\nexport class JSONMessageReader extends MessageReader {\n    private _schema = false;\n    private _json: ArrowJSON;\n    private _body: any[] = [];\n    private _batchIndex = 0;\n    private _dictionaryIndex = 0;\n    constructor(source: ArrowJSON | ArrowJSONLike) {\n        super(new Uint8Array(0));\n        this._json = source instanceof ArrowJSON ? source : new ArrowJSON(source);\n    }\n    public next() {\n        const { _json } = this;\n        if (!this._schema) {\n            this._schema = true;\n            const message = Message.fromJSON(_json.schema, MessageHeader.Schema);\n            return { done: false, value: message };\n        }\n        if (this._dictionaryIndex < _json.dictionaries.length) {\n            const batch = _json.dictionaries[this._dictionaryIndex++];\n            this._body = batch['data']['columns'];\n            const message = Message.fromJSON(batch, MessageHeader.DictionaryBatch);\n            return { done: false, value: message };\n        }\n        if (this._batchIndex < _json.batches.length) {\n            const batch = _json.batches[this._batchIndex++];\n            this._body = batch['columns'];\n            const message = Message.fromJSON(batch, MessageHeader.RecordBatch);\n            return { done: false, value: message };\n        }\n        this._body = [];\n        return ITERATOR_DONE;\n    }\n    public readMessageBody(_bodyLength?: number) {\n        return flattenDataSources(this._body) as any;\n        function flattenDataSources(xs: any[]): any[][] {\n            return (xs || []).reduce<any[][]>((buffers, column: any) => [\n                ...buffers,\n                ...(column['VALIDITY'] && [column['VALIDITY']] || []),\n                ...(column['TYPE'] && [column['TYPE']] || []),\n                ...(column['OFFSET'] && [column['OFFSET']] || []),\n                ...(column['DATA'] && [column['DATA']] || []),\n                ...flattenDataSources(column['children'])\n            ], [] as any[][]);\n        }\n    }\n    public readMessage<T extends MessageHeader>(type?: T | null) {\n        let r: IteratorResult<Message<T>>;\n        if ((r = this.next()).done) { return null; }\n        if ((type != null) && r.value.headerType !== type) {\n            throw new Error(invalidMessageType(type));\n        }\n        return r.value;\n    }\n    public readSchema() {\n        const type = MessageHeader.Schema;\n        const message = this.readMessage(type);\n        const schema = message && message.header();\n        if (!message || !schema) {\n            throw new Error(nullMessage(type));\n        }\n        return schema;\n    }\n}\n\n/** @ignore */\nexport const PADDING = 4;\n/** @ignore */\nexport const MAGIC_STR = 'ARROW1';\n/** @ignore */\nexport const MAGIC = new Uint8Array(MAGIC_STR.length);\n\nfor (let i = 0; i < MAGIC_STR.length; i += 1 | 0) {\n    MAGIC[i] = MAGIC_STR.charCodeAt(i);\n}\n\n/** @ignore */\nexport function checkForMagicArrowString(buffer: Uint8Array, index = 0) {\n    for (let i = -1, n = MAGIC.length; ++i < n;) {\n        if (MAGIC[i] !== buffer[index + i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/** @ignore */\nexport const magicLength = MAGIC.length;\n/** @ignore */\nexport const magicAndPadding = magicLength + PADDING;\n/** @ignore */\nexport const magicX2AndPadding = magicLength * 2 + PADDING;\n"]},"metadata":{},"sourceType":"module"}