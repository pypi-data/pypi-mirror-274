Metadata-Version: 2.1
Name: talus
Version: 1.0.0rc5
Summary: A wrapper for connecting to RabbitMQ which constrains clients to a single purpose channel (producer or consumer) with healing for intermittent connectivity.
Author-email: NSO / AURA <dkistdc@nso.edu>
License: BSD 3-Clause
Project-URL: repository, https://bitbucket.org/dkistdc/interservice-bus-adapter
Classifier: License :: OSI Approved :: MIT License
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.11
Requires-Python: >=3.11
Description-Content-Type: text/x-rst
License-File: LICENSE
Requires-Dist: pika >1.3
Requires-Dist: tenacity >=8.0
Requires-Dist: pydantic >=2.0
Provides-Extra: test
Requires-Dist: tox >=4 ; extra == 'test'
Requires-Dist: pytest ; extra == 'test'
Requires-Dist: pytest-cov ; extra == 'test'
Requires-Dist: Pygments ; extra == 'test'
Requires-Dist: PyPDF4 ; extra == 'test'

talus
=========

|codecov|

talus (noun) - ta·​lus | ˈtā-ləs: a slope formed especially by an accumulation of rock debris; Occasional habitat of the pika.

A wrapper for connecting to RabbitMQ which constrains clients to a single purpose channel (producer or consumer) with healing for intermittent connectivity.

Features
--------

- Guided separation of connections for producers and consumers

- Re-establish connections to the server when lost

- Constrained interface to support simple produce / consume use cases for direct exchanges

Installation
------------

.. code:: bash

   pip install talus

Examples
--------

**Creating a message class**

.. code:: python

     from talus.message import message_class

     @message_class(routing_key="message.m", queues=["message.q"])
     class MyMessage:
         a: str

**Consumer with defaults for connection and retry**

.. code:: python

     with DurableBlockingConsumerWrapper(consumer_queue='queue_name') as consumer:
        for method, properties, body in consumer.consume_generator(auto_ack=True):
            pass # DO Something with the message

**Consumer specifying connection and retry data**

.. code:: python

     with DurableBlockingConsumerWrapper(consumer_queue='queue_name',
        rabbitmq_host="localhost",
        rabbitmq_port5672,
        rabbitmq_user='guest',
        rabbitmq_pass='guest',
        retry_delay=1,
        retry_backoff=2,
        retry_jitter=(1, 10),
        retry_max_delay=300,
        prefetch_count=1,
        connection_name='consumer connection') as consumer:
        for method, properties, body in consumer.consume_generator(auto_ack=True):
            pass # DO Something with the message

**Producer with defaults for connection and retry**

.. code:: python

     with DurableBlockingProducerWrapper(producer_queue_bindings=[{"routing_key": "test.m", "bound_queue": "test.q"}, MyMessage.binding()],
        publish_exchange='amq.direct') as producer:
        producer.post('test.m', {'key': 'value'})
        producer.publish_message(MyMessage(a="s")) # using the message class from an earlier example






.. |codecov| image:: https://codecov.io/bb/dkistdc/interservice-bus-adapter/branch/master/graph/badge.svg
   :target: https://codecov.io/bb/dkistdc/interservice-bus-adapter
