

# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Common helper code.
#
# Ideally this would live in a separate .py file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Python
# helpers directly inline like we're doing here.

import os
import sys
import ctypes
import enum
import struct
import contextlib
import datetime
import typing
import platform

# Used for default argument values
_DEFAULT = object()


class _UniffiRustBuffer(ctypes.Structure):
    _fields_ = [
        ("capacity", ctypes.c_int32),
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    @staticmethod
    def alloc(size):
        return _rust_call(_UniffiLib.ffi_bdkffi_rustbuffer_alloc, size)

    @staticmethod
    def reserve(rbuf, additional):
        return _rust_call(_UniffiLib.ffi_bdkffi_rustbuffer_reserve, rbuf, additional)

    def free(self):
        return _rust_call(_UniffiLib.ffi_bdkffi_rustbuffer_free, self)

    def __str__(self):
        return "_UniffiRustBuffer(capacity={}, len={}, data={})".format(
            self.capacity,
            self.len,
            self.data[0:self.len]
        )

    @contextlib.contextmanager
    def alloc_with_builder(*args):
        """Context-manger to allocate a buffer using a _UniffiRustBufferBuilder.

        The allocated buffer will be automatically freed if an error occurs, ensuring that
        we don't accidentally leak it.
        """
        builder = _UniffiRustBufferBuilder()
        try:
            yield builder
        except:
            builder.discard()
            raise

    @contextlib.contextmanager
    def consume_with_stream(self):
        """Context-manager to consume a buffer using a _UniffiRustBufferStream.

        The _UniffiRustBuffer will be freed once the context-manager exits, ensuring that we don't
        leak it even if an error occurs.
        """
        try:
            s = _UniffiRustBufferStream.from_rust_buffer(self)
            yield s
            if s.remaining() != 0:
                raise RuntimeError("junk data left in buffer at end of consume_with_stream")
        finally:
            self.free()

    @contextlib.contextmanager
    def read_with_stream(self):
        """Context-manager to read a buffer using a _UniffiRustBufferStream.

        This is like consume_with_stream, but doesn't free the buffer afterwards.
        It should only be used with borrowed `_UniffiRustBuffer` data.
        """
        s = _UniffiRustBufferStream.from_rust_buffer(self)
        yield s
        if s.remaining() != 0:
            raise RuntimeError("junk data left in buffer at end of read_with_stream")

class _UniffiForeignBytes(ctypes.Structure):
    _fields_ = [
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    def __str__(self):
        return "_UniffiForeignBytes(len={}, data={})".format(self.len, self.data[0:self.len])


class _UniffiRustBufferStream:
    """
    Helper for structured reading of bytes from a _UniffiRustBuffer
    """

    def __init__(self, data, len):
        self.data = data
        self.len = len
        self.offset = 0

    @classmethod
    def from_rust_buffer(cls, buf):
        return cls(buf.data, buf.len)

    def remaining(self):
        return self.len - self.offset

    def _unpack_from(self, size, format):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        value = struct.unpack(format, self.data[self.offset:self.offset+size])[0]
        self.offset += size
        return value

    def read(self, size):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        data = self.data[self.offset:self.offset+size]
        self.offset += size
        return data

    def read_i8(self):
        return self._unpack_from(1, ">b")

    def read_u8(self):
        return self._unpack_from(1, ">B")

    def read_i16(self):
        return self._unpack_from(2, ">h")

    def read_u16(self):
        return self._unpack_from(2, ">H")

    def read_i32(self):
        return self._unpack_from(4, ">i")

    def read_u32(self):
        return self._unpack_from(4, ">I")

    def read_i64(self):
        return self._unpack_from(8, ">q")

    def read_u64(self):
        return self._unpack_from(8, ">Q")

    def read_float(self):
        v = self._unpack_from(4, ">f")
        return v

    def read_double(self):
        return self._unpack_from(8, ">d")

    def read_c_size_t(self):
        return self._unpack_from(ctypes.sizeof(ctypes.c_size_t) , "@N")

class _UniffiRustBufferBuilder:
    """
    Helper for structured writing of bytes into a _UniffiRustBuffer.
    """

    def __init__(self):
        self.rbuf = _UniffiRustBuffer.alloc(16)
        self.rbuf.len = 0

    def finalize(self):
        rbuf = self.rbuf
        self.rbuf = None
        return rbuf

    def discard(self):
        if self.rbuf is not None:
            rbuf = self.finalize()
            rbuf.free()

    @contextlib.contextmanager
    def _reserve(self, num_bytes):
        if self.rbuf.len + num_bytes > self.rbuf.capacity:
            self.rbuf = _UniffiRustBuffer.reserve(self.rbuf, num_bytes)
        yield None
        self.rbuf.len += num_bytes

    def _pack_into(self, size, format, value):
        with self._reserve(size):
            # XXX TODO: I feel like I should be able to use `struct.pack_into` here but can't figure it out.
            for i, byte in enumerate(struct.pack(format, value)):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write(self, value):
        with self._reserve(len(value)):
            for i, byte in enumerate(value):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write_i8(self, v):
        self._pack_into(1, ">b", v)

    def write_u8(self, v):
        self._pack_into(1, ">B", v)

    def write_i16(self, v):
        self._pack_into(2, ">h", v)

    def write_u16(self, v):
        self._pack_into(2, ">H", v)

    def write_i32(self, v):
        self._pack_into(4, ">i", v)

    def write_u32(self, v):
        self._pack_into(4, ">I", v)

    def write_i64(self, v):
        self._pack_into(8, ">q", v)

    def write_u64(self, v):
        self._pack_into(8, ">Q", v)

    def write_float(self, v):
        self._pack_into(4, ">f", v)

    def write_double(self, v):
        self._pack_into(8, ">d", v)

    def write_c_size_t(self, v):
        self._pack_into(ctypes.sizeof(ctypes.c_size_t) , "@N", v)
# A handful of classes and functions to support the generated data structures.
# This would be a good candidate for isolating in its own ffi-support lib.

class InternalError(Exception):
    pass

class _UniffiRustCallStatus(ctypes.Structure):
    """
    Error runtime.
    """
    _fields_ = [
        ("code", ctypes.c_int8),
        ("error_buf", _UniffiRustBuffer),
    ]

    # These match the values from the uniffi::rustcalls module
    CALL_SUCCESS = 0
    CALL_ERROR = 1
    CALL_PANIC = 2

    def __str__(self):
        if self.code == _UniffiRustCallStatus.CALL_SUCCESS:
            return "_UniffiRustCallStatus(CALL_SUCCESS)"
        elif self.code == _UniffiRustCallStatus.CALL_ERROR:
            return "_UniffiRustCallStatus(CALL_ERROR)"
        elif self.code == _UniffiRustCallStatus.CALL_PANIC:
            return "_UniffiRustCallStatus(CALL_PANIC)"
        else:
            return "_UniffiRustCallStatus(<invalid code>)"

def _rust_call(fn, *args):
    # Call a rust function
    return _rust_call_with_error(None, fn, *args)

def _rust_call_with_error(error_ffi_converter, fn, *args):
    # Call a rust function and handle any errors
    #
    # This function is used for rust calls that return Result<> and therefore can set the CALL_ERROR status code.
    # error_ffi_converter must be set to the _UniffiConverter for the error class that corresponds to the result.
    call_status = _UniffiRustCallStatus(code=_UniffiRustCallStatus.CALL_SUCCESS, error_buf=_UniffiRustBuffer(0, 0, None))

    args_with_error = args + (ctypes.byref(call_status),)
    result = fn(*args_with_error)
    _uniffi_check_call_status(error_ffi_converter, call_status)
    return result

def _uniffi_check_call_status(error_ffi_converter, call_status):
    if call_status.code == _UniffiRustCallStatus.CALL_SUCCESS:
        pass
    elif call_status.code == _UniffiRustCallStatus.CALL_ERROR:
        if error_ffi_converter is None:
            call_status.error_buf.free()
            raise InternalError("_rust_call_with_error: CALL_ERROR, but error_ffi_converter is None")
        else:
            raise error_ffi_converter.lift(call_status.error_buf)
    elif call_status.code == _UniffiRustCallStatus.CALL_PANIC:
        # When the rust code sees a panic, it tries to construct a _UniffiRustBuffer
        # with the message.  But if that code panics, then it just sends back
        # an empty buffer.
        if call_status.error_buf.len > 0:
            msg = _UniffiConverterString.lift(call_status.error_buf)
        else:
            msg = "Unknown rust panic"
        raise InternalError(msg)
    else:
        raise InternalError("Invalid _UniffiRustCallStatus code: {}".format(
            call_status.code))

# A function pointer for a callback as defined by UniFFI.
# Rust definition `fn(handle: u64, method: u32, args: _UniffiRustBuffer, buf_ptr: *mut _UniffiRustBuffer) -> int`
_UNIFFI_FOREIGN_CALLBACK_T = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_ulonglong, ctypes.c_ulong, ctypes.POINTER(ctypes.c_char), ctypes.c_int, ctypes.POINTER(_UniffiRustBuffer))

# UniFFI future continuation
_UNIFFI_FUTURE_CONTINUATION_T = ctypes.CFUNCTYPE(None, ctypes.c_size_t, ctypes.c_int8)

class _UniffiPointerManagerCPython:
    """
    Manage giving out pointers to Python objects on CPython

    This class is used to generate opaque pointers that reference Python objects to pass to Rust.
    It assumes a CPython platform.  See _UniffiPointerManagerGeneral for the alternative.
    """

    def new_pointer(self, obj):
        """
        Get a pointer for an object as a ctypes.c_size_t instance

        Each call to new_pointer() must be balanced with exactly one call to release_pointer()

        This returns a ctypes.c_size_t.  This is always the same size as a pointer and can be
        interchanged with pointers for FFI function arguments and return values.
        """
        # IncRef the object since we're going to pass a pointer to Rust
        ctypes.pythonapi.Py_IncRef(ctypes.py_object(obj))
        # id() is the object address on CPython
        # (https://docs.python.org/3/library/functions.html#id)
        return id(obj)

    def release_pointer(self, address):
        py_obj = ctypes.cast(address, ctypes.py_object)
        obj = py_obj.value
        ctypes.pythonapi.Py_DecRef(py_obj)
        return obj

    def lookup(self, address):
        return ctypes.cast(address, ctypes.py_object).value

class _UniffiPointerManagerGeneral:
    """
    Manage giving out pointers to Python objects on non-CPython platforms

    This has the same API as _UniffiPointerManagerCPython, but doesn't assume we're running on
    CPython and is slightly slower.

    Instead of using real pointers, it maps integer values to objects and returns the keys as
    c_size_t values.
    """

    def __init__(self):
        self._map = {}
        self._lock = threading.Lock()
        self._current_handle = 0

    def new_pointer(self, obj):
        with self._lock:
            handle = self._current_handle
            self._current_handle += 1
            self._map[handle] = obj
        return handle

    def release_pointer(self, handle):
        with self._lock:
            return self._map.pop(handle)

    def lookup(self, handle):
        with self._lock:
            return self._map[handle]

# Pick an pointer manager implementation based on the platform
if platform.python_implementation() == 'CPython':
    _UniffiPointerManager = _UniffiPointerManagerCPython # type: ignore
else:
    _UniffiPointerManager = _UniffiPointerManagerGeneral # type: ignore
# Types conforming to `_UniffiConverterPrimitive` pass themselves directly over the FFI.
class _UniffiConverterPrimitive:
    @classmethod
    def lift(cls, value):
        return value
 
    @classmethod
    def lower(cls, value):
        return value

class _UniffiConverterPrimitiveInt(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__index__()
        except Exception:
            raise TypeError("'{}' object cannot be interpreted as an integer".format(type(value).__name__))
        if not isinstance(value, int):
            raise TypeError("__index__ returned non-int (type {})".format(type(value).__name__))
        if not cls.VALUE_MIN <= value < cls.VALUE_MAX:
            raise ValueError("{} requires {} <= value < {}".format(cls.CLASS_NAME, cls.VALUE_MIN, cls.VALUE_MAX))

class _UniffiConverterPrimitiveFloat(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__float__()
        except Exception:
            raise TypeError("must be real number, not {}".format(type(value).__name__))
        if not isinstance(value, float):
            raise TypeError("__float__ returned non-float (type {})".format(type(value).__name__))

# Helper class for wrapper types that will always go through a _UniffiRustBuffer.
# Classes should inherit from this and implement the `read` and `write` static methods.
class _UniffiConverterRustBuffer:
    @classmethod
    def lift(cls, rbuf):
        with rbuf.consume_with_stream() as stream:
            return cls.read(stream)

    @classmethod
    def lower(cls, value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            cls.write(value, builder)
            return builder.finalize()

# Contains loading, initialization code, and the FFI Function declarations.
# Define some ctypes FFI types that we use in the library

"""
Function pointer for a Rust task, which a callback function that takes a opaque pointer
"""
_UNIFFI_RUST_TASK = ctypes.CFUNCTYPE(None, ctypes.c_void_p, ctypes.c_int8)

def _uniffi_future_callback_t(return_type):
    """
    Factory function to create callback function types for async functions
    """
    return ctypes.CFUNCTYPE(None, ctypes.c_size_t, return_type, _UniffiRustCallStatus)

def _uniffi_load_indirect():
    """
    This is how we find and load the dynamic library provided by the component.
    For now we just look it up by name.
    """
    if sys.platform == "darwin":
        libname = "lib{}.dylib"
    elif sys.platform.startswith("win"):
        # As of python3.8, ctypes does not seem to search $PATH when loading DLLs.
        # We could use `os.add_dll_directory` to configure the search path, but
        # it doesn't feel right to mess with application-wide settings. Let's
        # assume that the `.dll` is next to the `.py` file and load by full path.
        libname = os.path.join(
            os.path.dirname(__file__),
            "{}.dll",
        )
    else:
        # Anything else must be an ELF platform - Linux, *BSD, Solaris/illumos
        libname = "lib{}.so"

    libname = libname.format("bdkffi")
    path = os.path.join(os.path.dirname(__file__), libname)
    lib = ctypes.cdll.LoadLibrary(path)
    return lib

def _uniffi_check_contract_api_version(lib):
    # Get the bindings contract version from our ComponentInterface
    bindings_contract_version = 25
    # Get the scaffolding contract version by calling the into the dylib
    scaffolding_contract_version = lib.ffi_bdkffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version:
        raise InternalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")

def _uniffi_check_api_checksums(lib):
    if lib.uniffi_bdkffi_checksum_method_address_as_string() != 26179:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_address_is_valid_for_network() != 10350:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_address_network() != 33317:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_address_script_pubkey() != 10722:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_address_to_qr_uri() != 48141:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_amount_to_btc() != 52662:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_amount_to_sat() != 54936:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_bumpfeetxbuilder_enable_rbf() != 30060:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_bumpfeetxbuilder_enable_rbf_with_sequence() != 3682:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_bumpfeetxbuilder_finish() != 18299:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_descriptor_as_string() != 23756:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_descriptor_as_string_private() != 64930:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_descriptorpublickey_as_string() != 37256:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_descriptorpublickey_derive() != 42652:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_descriptorpublickey_extend() != 46128:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_descriptorsecretkey_as_public() != 56954:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_descriptorsecretkey_as_string() != 28335:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_descriptorsecretkey_derive() != 61335:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_descriptorsecretkey_extend() != 19969:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_descriptorsecretkey_secret_bytes() != 40876:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_electrumclient_broadcast() != 47170:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_electrumclient_full_scan() != 63481:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_electrumclient_sync() != 23534:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_esploraclient_broadcast() != 21200:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_esploraclient_full_scan() != 30443:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_esploraclient_sync() != 39911:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_feerate_to_sat_per_kwu() != 2433:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_feerate_to_sat_per_vb_ceil() != 21019:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_feerate_to_sat_per_vb_floor() != 54438:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_mnemonic_as_string() != 3181:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_psbt_extract_tx() != 60519:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_psbt_serialize() != 33309:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_script_to_bytes() != 31368:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_transaction_input() != 5374:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_transaction_is_coinbase() != 14454:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_transaction_is_explicitly_rbf() != 32682:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_transaction_is_lock_time_enabled() != 48885:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_transaction_lock_time() != 49321:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_transaction_output() != 30237:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_transaction_serialize() != 62862:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_transaction_total_size() != 12759:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_transaction_txid() != 29904:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_transaction_version() != 15271:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_transaction_vsize() != 3804:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_transaction_weight() != 21879:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_add_recipient() != 2935:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_add_unspendable() != 33319:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_add_utxo() != 43637:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_change_policy() != 22333:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_do_not_spend_change() != 51770:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_drain_to() != 21128:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_drain_wallet() != 5081:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_enable_rbf() != 38825:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_enable_rbf_with_sequence() != 26979:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_fee_absolute() != 59649:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_fee_rate() != 60371:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_finish() != 61082:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_manually_selected_only() != 12623:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_only_spend_change() != 18757:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_set_recipients() != 20461:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_unspendable() != 49004:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_apply_update() != 65428:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_calculate_fee() != 34670:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_calculate_fee_rate() != 61555:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_commit() != 59082:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_get_balance() != 41846:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_get_tx() != 59450:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_is_mine() != 10423:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_list_output() != 27359:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_list_unspent() != 25643:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_network() != 32197:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_reveal_next_address() != 53719:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_sent_and_received() != 15077:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_sign() != 15606:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_start_full_scan() != 18134:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_start_sync_with_revealed_spks() != 64824:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_transactions() != 37950:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_address_new() != 45929:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_amount_from_btc() != 13049:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_amount_from_sat() != 52691:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_bumpfeetxbuilder_new() != 4758:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_derivationpath_new() != 24471:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_descriptor_new() != 56307:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip44() != 46337:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip44_public() != 54845:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip49() != 56932:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip49_public() != 16380:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip84() != 41357:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip84_public() != 3965:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip86() != 19316:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip86_public() != 48565:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_descriptorpublickey_from_string() != 20475:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_descriptorsecretkey_from_string() != 51341:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_descriptorsecretkey_new() != 47131:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_electrumclient_new() != 28947:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_esploraclient_new() != 45557:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_feerate_from_sat_per_kwu() != 60699:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_feerate_from_sat_per_vb() != 50427:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_mnemonic_from_entropy() != 57762:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_mnemonic_from_string() != 41785:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_mnemonic_new() != 26468:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_psbt_new() != 58680:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_script_new() != 36370:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_transaction_new() != 45575:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_txbuilder_new() != 978:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_wallet_new() != 64341:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_wallet_new_no_persist() != 44289:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")

# A ctypes library to expose the extern-C FFI definitions.
# This is an implementation detail which will be called internally by the public API.

_UniffiLib = _uniffi_load_indirect()
_UniffiLib.uniffi_bdkffi_fn_clone_address.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_address.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_address.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_address.restype = None
_UniffiLib.uniffi_bdkffi_fn_constructor_address_new.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_address_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_address_as_string.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_address_as_string.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_address_is_valid_for_network.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_address_is_valid_for_network.restype = ctypes.c_int8
_UniffiLib.uniffi_bdkffi_fn_method_address_network.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_address_network.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_address_script_pubkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_address_script_pubkey.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_address_to_qr_uri.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_address_to_qr_uri.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_clone_amount.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_amount.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_amount.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_amount.restype = None
_UniffiLib.uniffi_bdkffi_fn_constructor_amount_from_btc.argtypes = (
    ctypes.c_double,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_amount_from_btc.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_constructor_amount_from_sat.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_amount_from_sat.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_amount_to_btc.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_amount_to_btc.restype = ctypes.c_double
_UniffiLib.uniffi_bdkffi_fn_method_amount_to_sat.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_amount_to_sat.restype = ctypes.c_uint64
_UniffiLib.uniffi_bdkffi_fn_clone_bumpfeetxbuilder.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_bumpfeetxbuilder.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_bumpfeetxbuilder.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_bumpfeetxbuilder.restype = None
_UniffiLib.uniffi_bdkffi_fn_constructor_bumpfeetxbuilder_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_bumpfeetxbuilder_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_bumpfeetxbuilder_enable_rbf.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_bumpfeetxbuilder_enable_rbf.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_bumpfeetxbuilder_enable_rbf_with_sequence.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_bumpfeetxbuilder_enable_rbf_with_sequence.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_bumpfeetxbuilder_finish.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_bumpfeetxbuilder_finish.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_clone_derivationpath.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_derivationpath.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_derivationpath.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_derivationpath.restype = None
_UniffiLib.uniffi_bdkffi_fn_constructor_derivationpath_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_derivationpath_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_clone_descriptor.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_descriptor.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_descriptor.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_descriptor.restype = None
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip44.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip44.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip44_public.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip44_public.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip49.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip49.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip49_public.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip49_public.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip84.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip84.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip84_public.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip84_public.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip86.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip86.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip86_public.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip86_public.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_descriptor_as_string.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_descriptor_as_string.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_descriptor_as_string_private.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_descriptor_as_string_private.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_clone_descriptorpublickey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_descriptorpublickey.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_descriptorpublickey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_descriptorpublickey.restype = None
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptorpublickey_from_string.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptorpublickey_from_string.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_descriptorpublickey_as_string.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_descriptorpublickey_as_string.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_descriptorpublickey_derive.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_descriptorpublickey_derive.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_descriptorpublickey_extend.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_descriptorpublickey_extend.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_clone_descriptorsecretkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_descriptorsecretkey.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_descriptorsecretkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_descriptorsecretkey.restype = None
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptorsecretkey_from_string.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptorsecretkey_from_string.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptorsecretkey_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptorsecretkey_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_descriptorsecretkey_as_public.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_descriptorsecretkey_as_public.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_descriptorsecretkey_as_string.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_descriptorsecretkey_as_string.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_descriptorsecretkey_derive.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_descriptorsecretkey_derive.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_descriptorsecretkey_extend.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_descriptorsecretkey_extend.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_descriptorsecretkey_secret_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_descriptorsecretkey_secret_bytes.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_clone_electrumclient.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_electrumclient.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_electrumclient.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_electrumclient.restype = None
_UniffiLib.uniffi_bdkffi_fn_constructor_electrumclient_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_electrumclient_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_electrumclient_broadcast.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_electrumclient_broadcast.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_electrumclient_full_scan.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.c_uint64,
    ctypes.c_int8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_electrumclient_full_scan.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_electrumclient_sync.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.c_int8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_electrumclient_sync.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_clone_esploraclient.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_esploraclient.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_esploraclient.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_esploraclient.restype = None
_UniffiLib.uniffi_bdkffi_fn_constructor_esploraclient_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_esploraclient_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_esploraclient_broadcast.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_esploraclient_broadcast.restype = None
_UniffiLib.uniffi_bdkffi_fn_method_esploraclient_full_scan.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_esploraclient_full_scan.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_esploraclient_sync.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_esploraclient_sync.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_clone_feerate.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_feerate.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_feerate.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_feerate.restype = None
_UniffiLib.uniffi_bdkffi_fn_constructor_feerate_from_sat_per_kwu.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_feerate_from_sat_per_kwu.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_constructor_feerate_from_sat_per_vb.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_feerate_from_sat_per_vb.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_feerate_to_sat_per_kwu.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_feerate_to_sat_per_kwu.restype = ctypes.c_uint64
_UniffiLib.uniffi_bdkffi_fn_method_feerate_to_sat_per_vb_ceil.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_feerate_to_sat_per_vb_ceil.restype = ctypes.c_uint64
_UniffiLib.uniffi_bdkffi_fn_method_feerate_to_sat_per_vb_floor.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_feerate_to_sat_per_vb_floor.restype = ctypes.c_uint64
_UniffiLib.uniffi_bdkffi_fn_clone_fullscanrequest.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_fullscanrequest.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_fullscanrequest.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_fullscanrequest.restype = None
_UniffiLib.uniffi_bdkffi_fn_clone_mnemonic.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_mnemonic.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_mnemonic.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_mnemonic.restype = None
_UniffiLib.uniffi_bdkffi_fn_constructor_mnemonic_from_entropy.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_mnemonic_from_entropy.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_constructor_mnemonic_from_string.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_mnemonic_from_string.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_constructor_mnemonic_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_mnemonic_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_mnemonic_as_string.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_mnemonic_as_string.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_clone_psbt.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_psbt.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_psbt.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_psbt.restype = None
_UniffiLib.uniffi_bdkffi_fn_constructor_psbt_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_psbt_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_psbt_extract_tx.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_psbt_extract_tx.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_psbt_serialize.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_psbt_serialize.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_clone_script.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_script.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_script.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_script.restype = None
_UniffiLib.uniffi_bdkffi_fn_constructor_script_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_script_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_script_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_script_to_bytes.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_clone_syncrequest.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_syncrequest.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_syncrequest.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_syncrequest.restype = None
_UniffiLib.uniffi_bdkffi_fn_clone_transaction.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_transaction.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_transaction.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_transaction.restype = None
_UniffiLib.uniffi_bdkffi_fn_constructor_transaction_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_transaction_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_transaction_input.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_transaction_input.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_transaction_is_coinbase.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_transaction_is_coinbase.restype = ctypes.c_int8
_UniffiLib.uniffi_bdkffi_fn_method_transaction_is_explicitly_rbf.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_transaction_is_explicitly_rbf.restype = ctypes.c_int8
_UniffiLib.uniffi_bdkffi_fn_method_transaction_is_lock_time_enabled.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_transaction_is_lock_time_enabled.restype = ctypes.c_int8
_UniffiLib.uniffi_bdkffi_fn_method_transaction_lock_time.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_transaction_lock_time.restype = ctypes.c_uint32
_UniffiLib.uniffi_bdkffi_fn_method_transaction_output.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_transaction_output.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_transaction_serialize.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_transaction_serialize.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_transaction_total_size.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_transaction_total_size.restype = ctypes.c_uint64
_UniffiLib.uniffi_bdkffi_fn_method_transaction_txid.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_transaction_txid.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_transaction_version.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_transaction_version.restype = ctypes.c_int32
_UniffiLib.uniffi_bdkffi_fn_method_transaction_vsize.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_transaction_vsize.restype = ctypes.c_uint64
_UniffiLib.uniffi_bdkffi_fn_method_transaction_weight.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_transaction_weight.restype = ctypes.c_uint64
_UniffiLib.uniffi_bdkffi_fn_clone_txbuilder.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_txbuilder.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_txbuilder.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_txbuilder.restype = None
_UniffiLib.uniffi_bdkffi_fn_constructor_txbuilder_new.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_txbuilder_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_add_recipient.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_add_recipient.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_add_unspendable.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_add_unspendable.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_add_utxo.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_add_utxo.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_change_policy.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_change_policy.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_do_not_spend_change.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_do_not_spend_change.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_drain_to.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_drain_to.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_drain_wallet.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_drain_wallet.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_enable_rbf.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_enable_rbf.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_enable_rbf_with_sequence.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_enable_rbf_with_sequence.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_fee_absolute.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_fee_absolute.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_fee_rate.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_fee_rate.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_finish.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_finish.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_manually_selected_only.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_manually_selected_only.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_only_spend_change.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_only_spend_change.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_set_recipients.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_set_recipients.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_unspendable.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_unspendable.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_clone_update.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_update.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_update.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_update.restype = None
_UniffiLib.uniffi_bdkffi_fn_clone_wallet.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_wallet.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_wallet.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_wallet.restype = None
_UniffiLib.uniffi_bdkffi_fn_constructor_wallet_new.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_wallet_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_constructor_wallet_new_no_persist.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_wallet_new_no_persist.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_wallet_apply_update.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_apply_update.restype = None
_UniffiLib.uniffi_bdkffi_fn_method_wallet_calculate_fee.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_calculate_fee.restype = ctypes.c_uint64
_UniffiLib.uniffi_bdkffi_fn_method_wallet_calculate_fee_rate.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_calculate_fee_rate.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_wallet_commit.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_commit.restype = ctypes.c_int8
_UniffiLib.uniffi_bdkffi_fn_method_wallet_get_balance.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_get_balance.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_wallet_get_tx.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_get_tx.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_wallet_is_mine.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_is_mine.restype = ctypes.c_int8
_UniffiLib.uniffi_bdkffi_fn_method_wallet_list_output.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_list_output.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_wallet_list_unspent.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_list_unspent.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_wallet_network.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_network.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_wallet_reveal_next_address.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_reveal_next_address.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_wallet_sent_and_received.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_sent_and_received.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_wallet_sign.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_sign.restype = ctypes.c_int8
_UniffiLib.uniffi_bdkffi_fn_method_wallet_start_full_scan.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_start_full_scan.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_wallet_start_sync_with_revealed_spks.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_start_sync_with_revealed_spks.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_wallet_transactions.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_transactions.restype = _UniffiRustBuffer
_UniffiLib.ffi_bdkffi_rustbuffer_alloc.argtypes = (
    ctypes.c_int32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rustbuffer_alloc.restype = _UniffiRustBuffer
_UniffiLib.ffi_bdkffi_rustbuffer_from_bytes.argtypes = (
    _UniffiForeignBytes,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rustbuffer_from_bytes.restype = _UniffiRustBuffer
_UniffiLib.ffi_bdkffi_rustbuffer_free.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rustbuffer_free.restype = None
_UniffiLib.ffi_bdkffi_rustbuffer_reserve.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_int32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rustbuffer_reserve.restype = _UniffiRustBuffer
_UniffiLib.ffi_bdkffi_rust_future_poll_u8.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_bdkffi_rust_future_poll_u8.restype = None
_UniffiLib.ffi_bdkffi_rust_future_cancel_u8.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bdkffi_rust_future_cancel_u8.restype = None
_UniffiLib.ffi_bdkffi_rust_future_free_u8.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bdkffi_rust_future_free_u8.restype = None
_UniffiLib.ffi_bdkffi_rust_future_complete_u8.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rust_future_complete_u8.restype = ctypes.c_uint8
_UniffiLib.ffi_bdkffi_rust_future_poll_i8.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_bdkffi_rust_future_poll_i8.restype = None
_UniffiLib.ffi_bdkffi_rust_future_cancel_i8.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bdkffi_rust_future_cancel_i8.restype = None
_UniffiLib.ffi_bdkffi_rust_future_free_i8.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bdkffi_rust_future_free_i8.restype = None
_UniffiLib.ffi_bdkffi_rust_future_complete_i8.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rust_future_complete_i8.restype = ctypes.c_int8
_UniffiLib.ffi_bdkffi_rust_future_poll_u16.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_bdkffi_rust_future_poll_u16.restype = None
_UniffiLib.ffi_bdkffi_rust_future_cancel_u16.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bdkffi_rust_future_cancel_u16.restype = None
_UniffiLib.ffi_bdkffi_rust_future_free_u16.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bdkffi_rust_future_free_u16.restype = None
_UniffiLib.ffi_bdkffi_rust_future_complete_u16.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rust_future_complete_u16.restype = ctypes.c_uint16
_UniffiLib.ffi_bdkffi_rust_future_poll_i16.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_bdkffi_rust_future_poll_i16.restype = None
_UniffiLib.ffi_bdkffi_rust_future_cancel_i16.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bdkffi_rust_future_cancel_i16.restype = None
_UniffiLib.ffi_bdkffi_rust_future_free_i16.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bdkffi_rust_future_free_i16.restype = None
_UniffiLib.ffi_bdkffi_rust_future_complete_i16.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rust_future_complete_i16.restype = ctypes.c_int16
_UniffiLib.ffi_bdkffi_rust_future_poll_u32.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_bdkffi_rust_future_poll_u32.restype = None
_UniffiLib.ffi_bdkffi_rust_future_cancel_u32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bdkffi_rust_future_cancel_u32.restype = None
_UniffiLib.ffi_bdkffi_rust_future_free_u32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bdkffi_rust_future_free_u32.restype = None
_UniffiLib.ffi_bdkffi_rust_future_complete_u32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rust_future_complete_u32.restype = ctypes.c_uint32
_UniffiLib.ffi_bdkffi_rust_future_poll_i32.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_bdkffi_rust_future_poll_i32.restype = None
_UniffiLib.ffi_bdkffi_rust_future_cancel_i32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bdkffi_rust_future_cancel_i32.restype = None
_UniffiLib.ffi_bdkffi_rust_future_free_i32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bdkffi_rust_future_free_i32.restype = None
_UniffiLib.ffi_bdkffi_rust_future_complete_i32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rust_future_complete_i32.restype = ctypes.c_int32
_UniffiLib.ffi_bdkffi_rust_future_poll_u64.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_bdkffi_rust_future_poll_u64.restype = None
_UniffiLib.ffi_bdkffi_rust_future_cancel_u64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bdkffi_rust_future_cancel_u64.restype = None
_UniffiLib.ffi_bdkffi_rust_future_free_u64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bdkffi_rust_future_free_u64.restype = None
_UniffiLib.ffi_bdkffi_rust_future_complete_u64.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rust_future_complete_u64.restype = ctypes.c_uint64
_UniffiLib.ffi_bdkffi_rust_future_poll_i64.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_bdkffi_rust_future_poll_i64.restype = None
_UniffiLib.ffi_bdkffi_rust_future_cancel_i64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bdkffi_rust_future_cancel_i64.restype = None
_UniffiLib.ffi_bdkffi_rust_future_free_i64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bdkffi_rust_future_free_i64.restype = None
_UniffiLib.ffi_bdkffi_rust_future_complete_i64.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rust_future_complete_i64.restype = ctypes.c_int64
_UniffiLib.ffi_bdkffi_rust_future_poll_f32.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_bdkffi_rust_future_poll_f32.restype = None
_UniffiLib.ffi_bdkffi_rust_future_cancel_f32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bdkffi_rust_future_cancel_f32.restype = None
_UniffiLib.ffi_bdkffi_rust_future_free_f32.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bdkffi_rust_future_free_f32.restype = None
_UniffiLib.ffi_bdkffi_rust_future_complete_f32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rust_future_complete_f32.restype = ctypes.c_float
_UniffiLib.ffi_bdkffi_rust_future_poll_f64.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_bdkffi_rust_future_poll_f64.restype = None
_UniffiLib.ffi_bdkffi_rust_future_cancel_f64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bdkffi_rust_future_cancel_f64.restype = None
_UniffiLib.ffi_bdkffi_rust_future_free_f64.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bdkffi_rust_future_free_f64.restype = None
_UniffiLib.ffi_bdkffi_rust_future_complete_f64.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rust_future_complete_f64.restype = ctypes.c_double
_UniffiLib.ffi_bdkffi_rust_future_poll_pointer.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_bdkffi_rust_future_poll_pointer.restype = None
_UniffiLib.ffi_bdkffi_rust_future_cancel_pointer.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bdkffi_rust_future_cancel_pointer.restype = None
_UniffiLib.ffi_bdkffi_rust_future_free_pointer.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bdkffi_rust_future_free_pointer.restype = None
_UniffiLib.ffi_bdkffi_rust_future_complete_pointer.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rust_future_complete_pointer.restype = ctypes.c_void_p
_UniffiLib.ffi_bdkffi_rust_future_poll_rust_buffer.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_bdkffi_rust_future_poll_rust_buffer.restype = None
_UniffiLib.ffi_bdkffi_rust_future_cancel_rust_buffer.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bdkffi_rust_future_cancel_rust_buffer.restype = None
_UniffiLib.ffi_bdkffi_rust_future_free_rust_buffer.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bdkffi_rust_future_free_rust_buffer.restype = None
_UniffiLib.ffi_bdkffi_rust_future_complete_rust_buffer.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rust_future_complete_rust_buffer.restype = _UniffiRustBuffer
_UniffiLib.ffi_bdkffi_rust_future_poll_void.argtypes = (
    ctypes.c_void_p,
    _UNIFFI_FUTURE_CONTINUATION_T,
    ctypes.c_size_t,
)
_UniffiLib.ffi_bdkffi_rust_future_poll_void.restype = None
_UniffiLib.ffi_bdkffi_rust_future_cancel_void.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bdkffi_rust_future_cancel_void.restype = None
_UniffiLib.ffi_bdkffi_rust_future_free_void.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.ffi_bdkffi_rust_future_free_void.restype = None
_UniffiLib.ffi_bdkffi_rust_future_complete_void.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rust_future_complete_void.restype = None
_UniffiLib.uniffi_bdkffi_checksum_method_address_as_string.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_address_as_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_address_is_valid_for_network.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_address_is_valid_for_network.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_address_network.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_address_network.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_address_script_pubkey.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_address_script_pubkey.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_address_to_qr_uri.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_address_to_qr_uri.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_amount_to_btc.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_amount_to_btc.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_amount_to_sat.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_amount_to_sat.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_bumpfeetxbuilder_enable_rbf.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_bumpfeetxbuilder_enable_rbf.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_bumpfeetxbuilder_enable_rbf_with_sequence.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_bumpfeetxbuilder_enable_rbf_with_sequence.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_bumpfeetxbuilder_finish.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_bumpfeetxbuilder_finish.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_descriptor_as_string.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_descriptor_as_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_descriptor_as_string_private.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_descriptor_as_string_private.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_descriptorpublickey_as_string.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_descriptorpublickey_as_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_descriptorpublickey_derive.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_descriptorpublickey_derive.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_descriptorpublickey_extend.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_descriptorpublickey_extend.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_descriptorsecretkey_as_public.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_descriptorsecretkey_as_public.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_descriptorsecretkey_as_string.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_descriptorsecretkey_as_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_descriptorsecretkey_derive.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_descriptorsecretkey_derive.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_descriptorsecretkey_extend.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_descriptorsecretkey_extend.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_descriptorsecretkey_secret_bytes.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_descriptorsecretkey_secret_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_electrumclient_broadcast.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_electrumclient_broadcast.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_electrumclient_full_scan.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_electrumclient_full_scan.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_electrumclient_sync.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_electrumclient_sync.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_esploraclient_broadcast.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_esploraclient_broadcast.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_esploraclient_full_scan.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_esploraclient_full_scan.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_esploraclient_sync.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_esploraclient_sync.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_feerate_to_sat_per_kwu.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_feerate_to_sat_per_kwu.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_feerate_to_sat_per_vb_ceil.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_feerate_to_sat_per_vb_ceil.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_feerate_to_sat_per_vb_floor.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_feerate_to_sat_per_vb_floor.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_mnemonic_as_string.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_mnemonic_as_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_psbt_extract_tx.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_psbt_extract_tx.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_psbt_serialize.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_psbt_serialize.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_script_to_bytes.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_script_to_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_input.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_input.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_is_coinbase.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_is_coinbase.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_is_explicitly_rbf.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_is_explicitly_rbf.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_is_lock_time_enabled.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_is_lock_time_enabled.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_lock_time.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_lock_time.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_output.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_output.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_serialize.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_serialize.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_total_size.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_total_size.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_txid.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_txid.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_version.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_version.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_vsize.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_vsize.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_weight.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_weight.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_add_recipient.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_add_recipient.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_add_unspendable.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_add_unspendable.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_add_utxo.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_add_utxo.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_change_policy.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_change_policy.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_do_not_spend_change.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_do_not_spend_change.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_drain_to.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_drain_to.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_drain_wallet.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_drain_wallet.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_enable_rbf.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_enable_rbf.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_enable_rbf_with_sequence.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_enable_rbf_with_sequence.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_fee_absolute.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_fee_absolute.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_fee_rate.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_fee_rate.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_finish.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_finish.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_manually_selected_only.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_manually_selected_only.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_only_spend_change.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_only_spend_change.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_set_recipients.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_set_recipients.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_unspendable.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_unspendable.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_apply_update.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_apply_update.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_calculate_fee.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_calculate_fee.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_calculate_fee_rate.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_calculate_fee_rate.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_commit.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_commit.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_get_balance.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_get_balance.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_get_tx.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_get_tx.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_is_mine.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_is_mine.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_list_output.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_list_output.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_list_unspent.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_list_unspent.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_network.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_network.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_reveal_next_address.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_reveal_next_address.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_sent_and_received.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_sent_and_received.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_sign.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_sign.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_start_full_scan.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_start_full_scan.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_start_sync_with_revealed_spks.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_start_sync_with_revealed_spks.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_transactions.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_transactions.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_address_new.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_address_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_amount_from_btc.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_amount_from_btc.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_amount_from_sat.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_amount_from_sat.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_bumpfeetxbuilder_new.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_bumpfeetxbuilder_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_derivationpath_new.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_derivationpath_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip44.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip44.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip44_public.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip44_public.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip49.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip49.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip49_public.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip49_public.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip84.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip84.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip84_public.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip84_public.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip86.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip86.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip86_public.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip86_public.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptorpublickey_from_string.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptorpublickey_from_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptorsecretkey_from_string.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptorsecretkey_from_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptorsecretkey_new.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptorsecretkey_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_electrumclient_new.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_electrumclient_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_esploraclient_new.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_esploraclient_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_feerate_from_sat_per_kwu.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_feerate_from_sat_per_kwu.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_feerate_from_sat_per_vb.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_feerate_from_sat_per_vb.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_mnemonic_from_entropy.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_mnemonic_from_entropy.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_mnemonic_from_string.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_mnemonic_from_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_mnemonic_new.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_mnemonic_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_psbt_new.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_psbt_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_script_new.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_script_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_transaction_new.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_transaction_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_txbuilder_new.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_txbuilder_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_wallet_new.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_wallet_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_wallet_new_no_persist.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_wallet_new_no_persist.restype = ctypes.c_uint16
_UniffiLib.ffi_bdkffi_uniffi_contract_version.argtypes = (
)
_UniffiLib.ffi_bdkffi_uniffi_contract_version.restype = ctypes.c_uint32
_uniffi_check_contract_api_version(_UniffiLib)
_uniffi_check_api_checksums(_UniffiLib)

# Async support

# Public interface members begin here.


class _UniffiConverterUInt8(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u8"
    VALUE_MIN = 0
    VALUE_MAX = 2**8

    @staticmethod
    def read(buf):
        return buf.read_u8()

    @staticmethod
    def write(value, buf):
        buf.write_u8(value)

class _UniffiConverterUInt16(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u16"
    VALUE_MIN = 0
    VALUE_MAX = 2**16

    @staticmethod
    def read(buf):
        return buf.read_u16()

    @staticmethod
    def write(value, buf):
        buf.write_u16(value)

class _UniffiConverterUInt32(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u32"
    VALUE_MIN = 0
    VALUE_MAX = 2**32

    @staticmethod
    def read(buf):
        return buf.read_u32()

    @staticmethod
    def write(value, buf):
        buf.write_u32(value)

class _UniffiConverterInt32(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "i32"
    VALUE_MIN = -2**31
    VALUE_MAX = 2**31

    @staticmethod
    def read(buf):
        return buf.read_i32()

    @staticmethod
    def write(value, buf):
        buf.write_i32(value)

class _UniffiConverterUInt64(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u64"
    VALUE_MIN = 0
    VALUE_MAX = 2**64

    @staticmethod
    def read(buf):
        return buf.read_u64()

    @staticmethod
    def write(value, buf):
        buf.write_u64(value)

class _UniffiConverterInt64(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "i64"
    VALUE_MIN = -2**63
    VALUE_MAX = 2**63

    @staticmethod
    def read(buf):
        return buf.read_i64()

    @staticmethod
    def write(value, buf):
        buf.write_i64(value)

class _UniffiConverterDouble(_UniffiConverterPrimitiveFloat):
    @staticmethod
    def read(buf):
        return buf.read_double()

    @staticmethod
    def write(value, buf):
        buf.write_double(value)

class _UniffiConverterBool:
    @classmethod
    def check_lower(cls, value):
        return not not value

    @classmethod
    def lower(cls, value):
        return 1 if value else 0

    @staticmethod
    def lift(value):
        return value != 0

    @classmethod
    def read(cls, buf):
        return cls.lift(buf.read_u8())

    @classmethod
    def write(cls, value, buf):
        buf.write_u8(value)

class _UniffiConverterString:
    @staticmethod
    def check_lower(value):
        if not isinstance(value, str):
            raise TypeError("argument must be str, not {}".format(type(value).__name__))
        return value

    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative string length")
        utf8_bytes = buf.read(size)
        return utf8_bytes.decode("utf-8")

    @staticmethod
    def write(value, buf):
        utf8_bytes = value.encode("utf-8")
        buf.write_i32(len(utf8_bytes))
        buf.write(utf8_bytes)

    @staticmethod
    def lift(buf):
        with buf.consume_with_stream() as stream:
            return stream.read(stream.remaining()).decode("utf-8")

    @staticmethod
    def lower(value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            builder.write(value.encode("utf-8"))
            return builder.finalize()



class AddressProtocol(typing.Protocol):
    def as_string(self, ):
        raise NotImplementedError
    def is_valid_for_network(self, network: "Network"):
        raise NotImplementedError
    def network(self, ):
        raise NotImplementedError
    def script_pubkey(self, ):
        raise NotImplementedError
    def to_qr_uri(self, ):
        raise NotImplementedError

class Address:

    _pointer: ctypes.c_void_p
    def __init__(self, address: "str",network: "Network"):
        _UniffiConverterString.check_lower(address)
        
        _UniffiConverterTypeNetwork.check_lower(network)
        
        self._pointer = _rust_call_with_error(_UniffiConverterTypeAddressError,_UniffiLib.uniffi_bdkffi_fn_constructor_address_new,
        _UniffiConverterString.lower(address),
        _UniffiConverterTypeNetwork.lower(network))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_free_address, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_address, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def as_string(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_address_as_string,self._uniffi_clone_pointer(),)
        )






    def is_valid_for_network(self, network: "Network") -> "bool":
        _UniffiConverterTypeNetwork.check_lower(network)
        
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_address_is_valid_for_network,self._uniffi_clone_pointer(),
        _UniffiConverterTypeNetwork.lower(network))
        )






    def network(self, ) -> "Network":
        return _UniffiConverterTypeNetwork.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_address_network,self._uniffi_clone_pointer(),)
        )






    def script_pubkey(self, ) -> "Script":
        return _UniffiConverterTypeScript.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_address_script_pubkey,self._uniffi_clone_pointer(),)
        )






    def to_qr_uri(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_address_to_qr_uri,self._uniffi_clone_pointer(),)
        )





class _UniffiConverterTypeAddress:

    @staticmethod
    def lift(value: int):
        return Address._make_instance_(value)

    @staticmethod
    def check_lower(value: Address):
        if not isinstance(value, Address):
            raise TypeError("Expected Address instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: AddressProtocol):
        if not isinstance(value, Address):
            raise TypeError("Expected Address instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: AddressProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class AmountProtocol(typing.Protocol):
    def to_btc(self, ):
        raise NotImplementedError
    def to_sat(self, ):
        raise NotImplementedError

class Amount:

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_free_amount, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_amount, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_btc(cls, from_btc: "float"):
        _UniffiConverterDouble.check_lower(from_btc)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeParseAmountError,_UniffiLib.uniffi_bdkffi_fn_constructor_amount_from_btc,
        _UniffiConverterDouble.lower(from_btc))
        return cls._make_instance_(pointer)


    @classmethod
    def from_sat(cls, from_sat: "int"):
        _UniffiConverterUInt64.check_lower(from_sat)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_bdkffi_fn_constructor_amount_from_sat,
        _UniffiConverterUInt64.lower(from_sat))
        return cls._make_instance_(pointer)



    def to_btc(self, ) -> "float":
        return _UniffiConverterDouble.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_amount_to_btc,self._uniffi_clone_pointer(),)
        )






    def to_sat(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_amount_to_sat,self._uniffi_clone_pointer(),)
        )





class _UniffiConverterTypeAmount:

    @staticmethod
    def lift(value: int):
        return Amount._make_instance_(value)

    @staticmethod
    def check_lower(value: Amount):
        if not isinstance(value, Amount):
            raise TypeError("Expected Amount instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: AmountProtocol):
        if not isinstance(value, Amount):
            raise TypeError("Expected Amount instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: AmountProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class BumpFeeTxBuilderProtocol(typing.Protocol):
    def enable_rbf(self, ):
        raise NotImplementedError
    def enable_rbf_with_sequence(self, nsequence: "int"):
        raise NotImplementedError
    def finish(self, wallet: "Wallet"):
        raise NotImplementedError

class BumpFeeTxBuilder:

    _pointer: ctypes.c_void_p
    def __init__(self, txid: "str",fee_rate: "FeeRate"):
        _UniffiConverterString.check_lower(txid)
        
        _UniffiConverterTypeFeeRate.check_lower(fee_rate)
        
        self._pointer = _rust_call(_UniffiLib.uniffi_bdkffi_fn_constructor_bumpfeetxbuilder_new,
        _UniffiConverterString.lower(txid),
        _UniffiConverterTypeFeeRate.lower(fee_rate))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_free_bumpfeetxbuilder, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_bumpfeetxbuilder, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def enable_rbf(self, ) -> "BumpFeeTxBuilder":
        return _UniffiConverterTypeBumpFeeTxBuilder.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_bumpfeetxbuilder_enable_rbf,self._uniffi_clone_pointer(),)
        )






    def enable_rbf_with_sequence(self, nsequence: "int") -> "BumpFeeTxBuilder":
        _UniffiConverterUInt32.check_lower(nsequence)
        
        return _UniffiConverterTypeBumpFeeTxBuilder.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_bumpfeetxbuilder_enable_rbf_with_sequence,self._uniffi_clone_pointer(),
        _UniffiConverterUInt32.lower(nsequence))
        )






    def finish(self, wallet: "Wallet") -> "Psbt":
        _UniffiConverterTypeWallet.check_lower(wallet)
        
        return _UniffiConverterTypePsbt.lift(
            _rust_call_with_error(
    _UniffiConverterTypeCreateTxError,_UniffiLib.uniffi_bdkffi_fn_method_bumpfeetxbuilder_finish,self._uniffi_clone_pointer(),
        _UniffiConverterTypeWallet.lower(wallet))
        )





class _UniffiConverterTypeBumpFeeTxBuilder:

    @staticmethod
    def lift(value: int):
        return BumpFeeTxBuilder._make_instance_(value)

    @staticmethod
    def check_lower(value: BumpFeeTxBuilder):
        if not isinstance(value, BumpFeeTxBuilder):
            raise TypeError("Expected BumpFeeTxBuilder instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: BumpFeeTxBuilderProtocol):
        if not isinstance(value, BumpFeeTxBuilder):
            raise TypeError("Expected BumpFeeTxBuilder instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: BumpFeeTxBuilderProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class DerivationPathProtocol(typing.Protocol):
    pass

class DerivationPath:

    _pointer: ctypes.c_void_p
    def __init__(self, path: "str"):
        _UniffiConverterString.check_lower(path)
        
        self._pointer = _rust_call_with_error(_UniffiConverterTypeBip32Error,_UniffiLib.uniffi_bdkffi_fn_constructor_derivationpath_new,
        _UniffiConverterString.lower(path))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_free_derivationpath, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_derivationpath, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

class _UniffiConverterTypeDerivationPath:

    @staticmethod
    def lift(value: int):
        return DerivationPath._make_instance_(value)

    @staticmethod
    def check_lower(value: DerivationPath):
        if not isinstance(value, DerivationPath):
            raise TypeError("Expected DerivationPath instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: DerivationPathProtocol):
        if not isinstance(value, DerivationPath):
            raise TypeError("Expected DerivationPath instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: DerivationPathProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class DescriptorProtocol(typing.Protocol):
    def as_string(self, ):
        raise NotImplementedError
    def as_string_private(self, ):
        raise NotImplementedError

class Descriptor:

    _pointer: ctypes.c_void_p
    def __init__(self, descriptor: "str",network: "Network"):
        _UniffiConverterString.check_lower(descriptor)
        
        _UniffiConverterTypeNetwork.check_lower(network)
        
        self._pointer = _rust_call_with_error(_UniffiConverterTypeDescriptorError,_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new,
        _UniffiConverterString.lower(descriptor),
        _UniffiConverterTypeNetwork.lower(network))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_free_descriptor, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_descriptor, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def new_bip44(cls, secret_key: "DescriptorSecretKey",keychain: "KeychainKind",network: "Network"):
        _UniffiConverterTypeDescriptorSecretKey.check_lower(secret_key)
        
        _UniffiConverterTypeKeychainKind.check_lower(keychain)
        
        _UniffiConverterTypeNetwork.check_lower(network)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip44,
        _UniffiConverterTypeDescriptorSecretKey.lower(secret_key),
        _UniffiConverterTypeKeychainKind.lower(keychain),
        _UniffiConverterTypeNetwork.lower(network))
        return cls._make_instance_(pointer)


    @classmethod
    def new_bip44_public(cls, public_key: "DescriptorPublicKey",fingerprint: "str",keychain: "KeychainKind",network: "Network"):
        _UniffiConverterTypeDescriptorPublicKey.check_lower(public_key)
        
        _UniffiConverterString.check_lower(fingerprint)
        
        _UniffiConverterTypeKeychainKind.check_lower(keychain)
        
        _UniffiConverterTypeNetwork.check_lower(network)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip44_public,
        _UniffiConverterTypeDescriptorPublicKey.lower(public_key),
        _UniffiConverterString.lower(fingerprint),
        _UniffiConverterTypeKeychainKind.lower(keychain),
        _UniffiConverterTypeNetwork.lower(network))
        return cls._make_instance_(pointer)


    @classmethod
    def new_bip49(cls, secret_key: "DescriptorSecretKey",keychain: "KeychainKind",network: "Network"):
        _UniffiConverterTypeDescriptorSecretKey.check_lower(secret_key)
        
        _UniffiConverterTypeKeychainKind.check_lower(keychain)
        
        _UniffiConverterTypeNetwork.check_lower(network)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip49,
        _UniffiConverterTypeDescriptorSecretKey.lower(secret_key),
        _UniffiConverterTypeKeychainKind.lower(keychain),
        _UniffiConverterTypeNetwork.lower(network))
        return cls._make_instance_(pointer)


    @classmethod
    def new_bip49_public(cls, public_key: "DescriptorPublicKey",fingerprint: "str",keychain: "KeychainKind",network: "Network"):
        _UniffiConverterTypeDescriptorPublicKey.check_lower(public_key)
        
        _UniffiConverterString.check_lower(fingerprint)
        
        _UniffiConverterTypeKeychainKind.check_lower(keychain)
        
        _UniffiConverterTypeNetwork.check_lower(network)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip49_public,
        _UniffiConverterTypeDescriptorPublicKey.lower(public_key),
        _UniffiConverterString.lower(fingerprint),
        _UniffiConverterTypeKeychainKind.lower(keychain),
        _UniffiConverterTypeNetwork.lower(network))
        return cls._make_instance_(pointer)


    @classmethod
    def new_bip84(cls, secret_key: "DescriptorSecretKey",keychain: "KeychainKind",network: "Network"):
        _UniffiConverterTypeDescriptorSecretKey.check_lower(secret_key)
        
        _UniffiConverterTypeKeychainKind.check_lower(keychain)
        
        _UniffiConverterTypeNetwork.check_lower(network)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip84,
        _UniffiConverterTypeDescriptorSecretKey.lower(secret_key),
        _UniffiConverterTypeKeychainKind.lower(keychain),
        _UniffiConverterTypeNetwork.lower(network))
        return cls._make_instance_(pointer)


    @classmethod
    def new_bip84_public(cls, public_key: "DescriptorPublicKey",fingerprint: "str",keychain: "KeychainKind",network: "Network"):
        _UniffiConverterTypeDescriptorPublicKey.check_lower(public_key)
        
        _UniffiConverterString.check_lower(fingerprint)
        
        _UniffiConverterTypeKeychainKind.check_lower(keychain)
        
        _UniffiConverterTypeNetwork.check_lower(network)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip84_public,
        _UniffiConverterTypeDescriptorPublicKey.lower(public_key),
        _UniffiConverterString.lower(fingerprint),
        _UniffiConverterTypeKeychainKind.lower(keychain),
        _UniffiConverterTypeNetwork.lower(network))
        return cls._make_instance_(pointer)


    @classmethod
    def new_bip86(cls, secret_key: "DescriptorSecretKey",keychain: "KeychainKind",network: "Network"):
        _UniffiConverterTypeDescriptorSecretKey.check_lower(secret_key)
        
        _UniffiConverterTypeKeychainKind.check_lower(keychain)
        
        _UniffiConverterTypeNetwork.check_lower(network)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip86,
        _UniffiConverterTypeDescriptorSecretKey.lower(secret_key),
        _UniffiConverterTypeKeychainKind.lower(keychain),
        _UniffiConverterTypeNetwork.lower(network))
        return cls._make_instance_(pointer)


    @classmethod
    def new_bip86_public(cls, public_key: "DescriptorPublicKey",fingerprint: "str",keychain: "KeychainKind",network: "Network"):
        _UniffiConverterTypeDescriptorPublicKey.check_lower(public_key)
        
        _UniffiConverterString.check_lower(fingerprint)
        
        _UniffiConverterTypeKeychainKind.check_lower(keychain)
        
        _UniffiConverterTypeNetwork.check_lower(network)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip86_public,
        _UniffiConverterTypeDescriptorPublicKey.lower(public_key),
        _UniffiConverterString.lower(fingerprint),
        _UniffiConverterTypeKeychainKind.lower(keychain),
        _UniffiConverterTypeNetwork.lower(network))
        return cls._make_instance_(pointer)



    def as_string(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_descriptor_as_string,self._uniffi_clone_pointer(),)
        )






    def as_string_private(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_descriptor_as_string_private,self._uniffi_clone_pointer(),)
        )





class _UniffiConverterTypeDescriptor:

    @staticmethod
    def lift(value: int):
        return Descriptor._make_instance_(value)

    @staticmethod
    def check_lower(value: Descriptor):
        if not isinstance(value, Descriptor):
            raise TypeError("Expected Descriptor instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: DescriptorProtocol):
        if not isinstance(value, Descriptor):
            raise TypeError("Expected Descriptor instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: DescriptorProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class DescriptorPublicKeyProtocol(typing.Protocol):
    def as_string(self, ):
        raise NotImplementedError
    def derive(self, path: "DerivationPath"):
        raise NotImplementedError
    def extend(self, path: "DerivationPath"):
        raise NotImplementedError

class DescriptorPublicKey:

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_free_descriptorpublickey, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_descriptorpublickey, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_string(cls, public_key: "str"):
        _UniffiConverterString.check_lower(public_key)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeDescriptorKeyError,_UniffiLib.uniffi_bdkffi_fn_constructor_descriptorpublickey_from_string,
        _UniffiConverterString.lower(public_key))
        return cls._make_instance_(pointer)



    def as_string(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_descriptorpublickey_as_string,self._uniffi_clone_pointer(),)
        )






    def derive(self, path: "DerivationPath") -> "DescriptorPublicKey":
        _UniffiConverterTypeDerivationPath.check_lower(path)
        
        return _UniffiConverterTypeDescriptorPublicKey.lift(
            _rust_call_with_error(
    _UniffiConverterTypeDescriptorKeyError,_UniffiLib.uniffi_bdkffi_fn_method_descriptorpublickey_derive,self._uniffi_clone_pointer(),
        _UniffiConverterTypeDerivationPath.lower(path))
        )






    def extend(self, path: "DerivationPath") -> "DescriptorPublicKey":
        _UniffiConverterTypeDerivationPath.check_lower(path)
        
        return _UniffiConverterTypeDescriptorPublicKey.lift(
            _rust_call_with_error(
    _UniffiConverterTypeDescriptorKeyError,_UniffiLib.uniffi_bdkffi_fn_method_descriptorpublickey_extend,self._uniffi_clone_pointer(),
        _UniffiConverterTypeDerivationPath.lower(path))
        )





class _UniffiConverterTypeDescriptorPublicKey:

    @staticmethod
    def lift(value: int):
        return DescriptorPublicKey._make_instance_(value)

    @staticmethod
    def check_lower(value: DescriptorPublicKey):
        if not isinstance(value, DescriptorPublicKey):
            raise TypeError("Expected DescriptorPublicKey instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: DescriptorPublicKeyProtocol):
        if not isinstance(value, DescriptorPublicKey):
            raise TypeError("Expected DescriptorPublicKey instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: DescriptorPublicKeyProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class DescriptorSecretKeyProtocol(typing.Protocol):
    def as_public(self, ):
        raise NotImplementedError
    def as_string(self, ):
        raise NotImplementedError
    def derive(self, path: "DerivationPath"):
        raise NotImplementedError
    def extend(self, path: "DerivationPath"):
        raise NotImplementedError
    def secret_bytes(self, ):
        raise NotImplementedError

class DescriptorSecretKey:

    _pointer: ctypes.c_void_p
    def __init__(self, network: "Network",mnemonic: "Mnemonic",password: "typing.Optional[str]"):
        _UniffiConverterTypeNetwork.check_lower(network)
        
        _UniffiConverterTypeMnemonic.check_lower(mnemonic)
        
        _UniffiConverterOptionalString.check_lower(password)
        
        self._pointer = _rust_call(_UniffiLib.uniffi_bdkffi_fn_constructor_descriptorsecretkey_new,
        _UniffiConverterTypeNetwork.lower(network),
        _UniffiConverterTypeMnemonic.lower(mnemonic),
        _UniffiConverterOptionalString.lower(password))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_free_descriptorsecretkey, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_descriptorsecretkey, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_string(cls, secret_key: "str"):
        _UniffiConverterString.check_lower(secret_key)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeDescriptorKeyError,_UniffiLib.uniffi_bdkffi_fn_constructor_descriptorsecretkey_from_string,
        _UniffiConverterString.lower(secret_key))
        return cls._make_instance_(pointer)



    def as_public(self, ) -> "DescriptorPublicKey":
        return _UniffiConverterTypeDescriptorPublicKey.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_descriptorsecretkey_as_public,self._uniffi_clone_pointer(),)
        )






    def as_string(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_descriptorsecretkey_as_string,self._uniffi_clone_pointer(),)
        )






    def derive(self, path: "DerivationPath") -> "DescriptorSecretKey":
        _UniffiConverterTypeDerivationPath.check_lower(path)
        
        return _UniffiConverterTypeDescriptorSecretKey.lift(
            _rust_call_with_error(
    _UniffiConverterTypeDescriptorKeyError,_UniffiLib.uniffi_bdkffi_fn_method_descriptorsecretkey_derive,self._uniffi_clone_pointer(),
        _UniffiConverterTypeDerivationPath.lower(path))
        )






    def extend(self, path: "DerivationPath") -> "DescriptorSecretKey":
        _UniffiConverterTypeDerivationPath.check_lower(path)
        
        return _UniffiConverterTypeDescriptorSecretKey.lift(
            _rust_call_with_error(
    _UniffiConverterTypeDescriptorKeyError,_UniffiLib.uniffi_bdkffi_fn_method_descriptorsecretkey_extend,self._uniffi_clone_pointer(),
        _UniffiConverterTypeDerivationPath.lower(path))
        )






    def secret_bytes(self, ) -> "typing.List[int]":
        return _UniffiConverterSequenceUInt8.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_descriptorsecretkey_secret_bytes,self._uniffi_clone_pointer(),)
        )





class _UniffiConverterTypeDescriptorSecretKey:

    @staticmethod
    def lift(value: int):
        return DescriptorSecretKey._make_instance_(value)

    @staticmethod
    def check_lower(value: DescriptorSecretKey):
        if not isinstance(value, DescriptorSecretKey):
            raise TypeError("Expected DescriptorSecretKey instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: DescriptorSecretKeyProtocol):
        if not isinstance(value, DescriptorSecretKey):
            raise TypeError("Expected DescriptorSecretKey instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: DescriptorSecretKeyProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class ElectrumClientProtocol(typing.Protocol):
    def broadcast(self, transaction: "Transaction"):
        raise NotImplementedError
    def full_scan(self, full_scan_request: "FullScanRequest",stop_gap: "int",batch_size: "int",fetch_prev_txouts: "bool"):
        raise NotImplementedError
    def sync(self, sync_request: "SyncRequest",batch_size: "int",fetch_prev_txouts: "bool"):
        raise NotImplementedError

class ElectrumClient:

    _pointer: ctypes.c_void_p
    def __init__(self, url: "str"):
        _UniffiConverterString.check_lower(url)
        
        self._pointer = _rust_call_with_error(_UniffiConverterTypeElectrumError,_UniffiLib.uniffi_bdkffi_fn_constructor_electrumclient_new,
        _UniffiConverterString.lower(url))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_free_electrumclient, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_electrumclient, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def broadcast(self, transaction: "Transaction") -> "str":
        _UniffiConverterTypeTransaction.check_lower(transaction)
        
        return _UniffiConverterString.lift(
            _rust_call_with_error(
    _UniffiConverterTypeElectrumError,_UniffiLib.uniffi_bdkffi_fn_method_electrumclient_broadcast,self._uniffi_clone_pointer(),
        _UniffiConverterTypeTransaction.lower(transaction))
        )






    def full_scan(self, full_scan_request: "FullScanRequest",stop_gap: "int",batch_size: "int",fetch_prev_txouts: "bool") -> "Update":
        _UniffiConverterTypeFullScanRequest.check_lower(full_scan_request)
        
        _UniffiConverterUInt64.check_lower(stop_gap)
        
        _UniffiConverterUInt64.check_lower(batch_size)
        
        _UniffiConverterBool.check_lower(fetch_prev_txouts)
        
        return _UniffiConverterTypeUpdate.lift(
            _rust_call_with_error(
    _UniffiConverterTypeElectrumError,_UniffiLib.uniffi_bdkffi_fn_method_electrumclient_full_scan,self._uniffi_clone_pointer(),
        _UniffiConverterTypeFullScanRequest.lower(full_scan_request),
        _UniffiConverterUInt64.lower(stop_gap),
        _UniffiConverterUInt64.lower(batch_size),
        _UniffiConverterBool.lower(fetch_prev_txouts))
        )






    def sync(self, sync_request: "SyncRequest",batch_size: "int",fetch_prev_txouts: "bool") -> "Update":
        _UniffiConverterTypeSyncRequest.check_lower(sync_request)
        
        _UniffiConverterUInt64.check_lower(batch_size)
        
        _UniffiConverterBool.check_lower(fetch_prev_txouts)
        
        return _UniffiConverterTypeUpdate.lift(
            _rust_call_with_error(
    _UniffiConverterTypeElectrumError,_UniffiLib.uniffi_bdkffi_fn_method_electrumclient_sync,self._uniffi_clone_pointer(),
        _UniffiConverterTypeSyncRequest.lower(sync_request),
        _UniffiConverterUInt64.lower(batch_size),
        _UniffiConverterBool.lower(fetch_prev_txouts))
        )





class _UniffiConverterTypeElectrumClient:

    @staticmethod
    def lift(value: int):
        return ElectrumClient._make_instance_(value)

    @staticmethod
    def check_lower(value: ElectrumClient):
        if not isinstance(value, ElectrumClient):
            raise TypeError("Expected ElectrumClient instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ElectrumClientProtocol):
        if not isinstance(value, ElectrumClient):
            raise TypeError("Expected ElectrumClient instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ElectrumClientProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class EsploraClientProtocol(typing.Protocol):
    def broadcast(self, transaction: "Transaction"):
        raise NotImplementedError
    def full_scan(self, full_scan_request: "FullScanRequest",stop_gap: "int",parallel_requests: "int"):
        raise NotImplementedError
    def sync(self, sync_request: "SyncRequest",parallel_requests: "int"):
        raise NotImplementedError

class EsploraClient:

    _pointer: ctypes.c_void_p
    def __init__(self, url: "str"):
        _UniffiConverterString.check_lower(url)
        
        self._pointer = _rust_call(_UniffiLib.uniffi_bdkffi_fn_constructor_esploraclient_new,
        _UniffiConverterString.lower(url))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_free_esploraclient, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_esploraclient, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def broadcast(self, transaction: "Transaction"):
        _UniffiConverterTypeTransaction.check_lower(transaction)
        
        _rust_call_with_error(
    _UniffiConverterTypeEsploraError,_UniffiLib.uniffi_bdkffi_fn_method_esploraclient_broadcast,self._uniffi_clone_pointer(),
        _UniffiConverterTypeTransaction.lower(transaction))







    def full_scan(self, full_scan_request: "FullScanRequest",stop_gap: "int",parallel_requests: "int") -> "Update":
        _UniffiConverterTypeFullScanRequest.check_lower(full_scan_request)
        
        _UniffiConverterUInt64.check_lower(stop_gap)
        
        _UniffiConverterUInt64.check_lower(parallel_requests)
        
        return _UniffiConverterTypeUpdate.lift(
            _rust_call_with_error(
    _UniffiConverterTypeEsploraError,_UniffiLib.uniffi_bdkffi_fn_method_esploraclient_full_scan,self._uniffi_clone_pointer(),
        _UniffiConverterTypeFullScanRequest.lower(full_scan_request),
        _UniffiConverterUInt64.lower(stop_gap),
        _UniffiConverterUInt64.lower(parallel_requests))
        )






    def sync(self, sync_request: "SyncRequest",parallel_requests: "int") -> "Update":
        _UniffiConverterTypeSyncRequest.check_lower(sync_request)
        
        _UniffiConverterUInt64.check_lower(parallel_requests)
        
        return _UniffiConverterTypeUpdate.lift(
            _rust_call_with_error(
    _UniffiConverterTypeEsploraError,_UniffiLib.uniffi_bdkffi_fn_method_esploraclient_sync,self._uniffi_clone_pointer(),
        _UniffiConverterTypeSyncRequest.lower(sync_request),
        _UniffiConverterUInt64.lower(parallel_requests))
        )





class _UniffiConverterTypeEsploraClient:

    @staticmethod
    def lift(value: int):
        return EsploraClient._make_instance_(value)

    @staticmethod
    def check_lower(value: EsploraClient):
        if not isinstance(value, EsploraClient):
            raise TypeError("Expected EsploraClient instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: EsploraClientProtocol):
        if not isinstance(value, EsploraClient):
            raise TypeError("Expected EsploraClient instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: EsploraClientProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class FeeRateProtocol(typing.Protocol):
    def to_sat_per_kwu(self, ):
        raise NotImplementedError
    def to_sat_per_vb_ceil(self, ):
        raise NotImplementedError
    def to_sat_per_vb_floor(self, ):
        raise NotImplementedError

class FeeRate:

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_free_feerate, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_feerate, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_sat_per_kwu(cls, sat_per_kwu: "int"):
        _UniffiConverterUInt64.check_lower(sat_per_kwu)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call(_UniffiLib.uniffi_bdkffi_fn_constructor_feerate_from_sat_per_kwu,
        _UniffiConverterUInt64.lower(sat_per_kwu))
        return cls._make_instance_(pointer)


    @classmethod
    def from_sat_per_vb(cls, sat_per_vb: "int"):
        _UniffiConverterUInt64.check_lower(sat_per_vb)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeFeeRateError,_UniffiLib.uniffi_bdkffi_fn_constructor_feerate_from_sat_per_vb,
        _UniffiConverterUInt64.lower(sat_per_vb))
        return cls._make_instance_(pointer)



    def to_sat_per_kwu(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_feerate_to_sat_per_kwu,self._uniffi_clone_pointer(),)
        )






    def to_sat_per_vb_ceil(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_feerate_to_sat_per_vb_ceil,self._uniffi_clone_pointer(),)
        )






    def to_sat_per_vb_floor(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_feerate_to_sat_per_vb_floor,self._uniffi_clone_pointer(),)
        )





class _UniffiConverterTypeFeeRate:

    @staticmethod
    def lift(value: int):
        return FeeRate._make_instance_(value)

    @staticmethod
    def check_lower(value: FeeRate):
        if not isinstance(value, FeeRate):
            raise TypeError("Expected FeeRate instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: FeeRateProtocol):
        if not isinstance(value, FeeRate):
            raise TypeError("Expected FeeRate instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: FeeRateProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class FullScanRequestProtocol(typing.Protocol):
    pass

class FullScanRequest:

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_free_fullscanrequest, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_fullscanrequest, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

class _UniffiConverterTypeFullScanRequest:

    @staticmethod
    def lift(value: int):
        return FullScanRequest._make_instance_(value)

    @staticmethod
    def check_lower(value: FullScanRequest):
        if not isinstance(value, FullScanRequest):
            raise TypeError("Expected FullScanRequest instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: FullScanRequestProtocol):
        if not isinstance(value, FullScanRequest):
            raise TypeError("Expected FullScanRequest instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: FullScanRequestProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class MnemonicProtocol(typing.Protocol):
    def as_string(self, ):
        raise NotImplementedError

class Mnemonic:

    _pointer: ctypes.c_void_p
    def __init__(self, word_count: "WordCount"):
        _UniffiConverterTypeWordCount.check_lower(word_count)
        
        self._pointer = _rust_call(_UniffiLib.uniffi_bdkffi_fn_constructor_mnemonic_new,
        _UniffiConverterTypeWordCount.lower(word_count))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_free_mnemonic, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_mnemonic, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_entropy(cls, entropy: "typing.List[int]"):
        _UniffiConverterSequenceUInt8.check_lower(entropy)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeBip39Error,_UniffiLib.uniffi_bdkffi_fn_constructor_mnemonic_from_entropy,
        _UniffiConverterSequenceUInt8.lower(entropy))
        return cls._make_instance_(pointer)


    @classmethod
    def from_string(cls, mnemonic: "str"):
        _UniffiConverterString.check_lower(mnemonic)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeBip39Error,_UniffiLib.uniffi_bdkffi_fn_constructor_mnemonic_from_string,
        _UniffiConverterString.lower(mnemonic))
        return cls._make_instance_(pointer)



    def as_string(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_mnemonic_as_string,self._uniffi_clone_pointer(),)
        )





class _UniffiConverterTypeMnemonic:

    @staticmethod
    def lift(value: int):
        return Mnemonic._make_instance_(value)

    @staticmethod
    def check_lower(value: Mnemonic):
        if not isinstance(value, Mnemonic):
            raise TypeError("Expected Mnemonic instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: MnemonicProtocol):
        if not isinstance(value, Mnemonic):
            raise TypeError("Expected Mnemonic instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: MnemonicProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class PsbtProtocol(typing.Protocol):
    def extract_tx(self, ):
        raise NotImplementedError
    def serialize(self, ):
        raise NotImplementedError

class Psbt:

    _pointer: ctypes.c_void_p
    def __init__(self, psbt_base64: "str"):
        _UniffiConverterString.check_lower(psbt_base64)
        
        self._pointer = _rust_call_with_error(_UniffiConverterTypePsbtParseError,_UniffiLib.uniffi_bdkffi_fn_constructor_psbt_new,
        _UniffiConverterString.lower(psbt_base64))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_free_psbt, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_psbt, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def extract_tx(self, ) -> "Transaction":
        return _UniffiConverterTypeTransaction.lift(
            _rust_call_with_error(
    _UniffiConverterTypeExtractTxError,_UniffiLib.uniffi_bdkffi_fn_method_psbt_extract_tx,self._uniffi_clone_pointer(),)
        )






    def serialize(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_psbt_serialize,self._uniffi_clone_pointer(),)
        )





class _UniffiConverterTypePsbt:

    @staticmethod
    def lift(value: int):
        return Psbt._make_instance_(value)

    @staticmethod
    def check_lower(value: Psbt):
        if not isinstance(value, Psbt):
            raise TypeError("Expected Psbt instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: PsbtProtocol):
        if not isinstance(value, Psbt):
            raise TypeError("Expected Psbt instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: PsbtProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class ScriptProtocol(typing.Protocol):
    def to_bytes(self, ):
        raise NotImplementedError

class Script:

    _pointer: ctypes.c_void_p
    def __init__(self, raw_output_script: "typing.List[int]"):
        _UniffiConverterSequenceUInt8.check_lower(raw_output_script)
        
        self._pointer = _rust_call(_UniffiLib.uniffi_bdkffi_fn_constructor_script_new,
        _UniffiConverterSequenceUInt8.lower(raw_output_script))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_free_script, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_script, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def to_bytes(self, ) -> "typing.List[int]":
        return _UniffiConverterSequenceUInt8.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_script_to_bytes,self._uniffi_clone_pointer(),)
        )





class _UniffiConverterTypeScript:

    @staticmethod
    def lift(value: int):
        return Script._make_instance_(value)

    @staticmethod
    def check_lower(value: Script):
        if not isinstance(value, Script):
            raise TypeError("Expected Script instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ScriptProtocol):
        if not isinstance(value, Script):
            raise TypeError("Expected Script instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ScriptProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class SyncRequestProtocol(typing.Protocol):
    pass

class SyncRequest:

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_free_syncrequest, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_syncrequest, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

class _UniffiConverterTypeSyncRequest:

    @staticmethod
    def lift(value: int):
        return SyncRequest._make_instance_(value)

    @staticmethod
    def check_lower(value: SyncRequest):
        if not isinstance(value, SyncRequest):
            raise TypeError("Expected SyncRequest instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: SyncRequestProtocol):
        if not isinstance(value, SyncRequest):
            raise TypeError("Expected SyncRequest instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: SyncRequestProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class TransactionProtocol(typing.Protocol):
    def input(self, ):
        raise NotImplementedError
    def is_coinbase(self, ):
        raise NotImplementedError
    def is_explicitly_rbf(self, ):
        raise NotImplementedError
    def is_lock_time_enabled(self, ):
        raise NotImplementedError
    def lock_time(self, ):
        raise NotImplementedError
    def output(self, ):
        raise NotImplementedError
    def serialize(self, ):
        raise NotImplementedError
    def total_size(self, ):
        raise NotImplementedError
    def txid(self, ):
        raise NotImplementedError
    def version(self, ):
        raise NotImplementedError
    def vsize(self, ):
        raise NotImplementedError
    def weight(self, ):
        raise NotImplementedError

class Transaction:

    _pointer: ctypes.c_void_p
    def __init__(self, transaction_bytes: "typing.List[int]"):
        _UniffiConverterSequenceUInt8.check_lower(transaction_bytes)
        
        self._pointer = _rust_call_with_error(_UniffiConverterTypeTransactionError,_UniffiLib.uniffi_bdkffi_fn_constructor_transaction_new,
        _UniffiConverterSequenceUInt8.lower(transaction_bytes))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_free_transaction, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_transaction, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def input(self, ) -> "typing.List[TxIn]":
        return _UniffiConverterSequenceTypeTxIn.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_transaction_input,self._uniffi_clone_pointer(),)
        )






    def is_coinbase(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_transaction_is_coinbase,self._uniffi_clone_pointer(),)
        )






    def is_explicitly_rbf(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_transaction_is_explicitly_rbf,self._uniffi_clone_pointer(),)
        )






    def is_lock_time_enabled(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_transaction_is_lock_time_enabled,self._uniffi_clone_pointer(),)
        )






    def lock_time(self, ) -> "int":
        return _UniffiConverterUInt32.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_transaction_lock_time,self._uniffi_clone_pointer(),)
        )






    def output(self, ) -> "typing.List[TxOut]":
        return _UniffiConverterSequenceTypeTxOut.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_transaction_output,self._uniffi_clone_pointer(),)
        )






    def serialize(self, ) -> "typing.List[int]":
        return _UniffiConverterSequenceUInt8.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_transaction_serialize,self._uniffi_clone_pointer(),)
        )






    def total_size(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_transaction_total_size,self._uniffi_clone_pointer(),)
        )






    def txid(self, ) -> "str":
        return _UniffiConverterString.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_transaction_txid,self._uniffi_clone_pointer(),)
        )






    def version(self, ) -> "int":
        return _UniffiConverterInt32.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_transaction_version,self._uniffi_clone_pointer(),)
        )






    def vsize(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_transaction_vsize,self._uniffi_clone_pointer(),)
        )






    def weight(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_transaction_weight,self._uniffi_clone_pointer(),)
        )





class _UniffiConverterTypeTransaction:

    @staticmethod
    def lift(value: int):
        return Transaction._make_instance_(value)

    @staticmethod
    def check_lower(value: Transaction):
        if not isinstance(value, Transaction):
            raise TypeError("Expected Transaction instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: TransactionProtocol):
        if not isinstance(value, Transaction):
            raise TypeError("Expected Transaction instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: TransactionProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class TxBuilderProtocol(typing.Protocol):
    def add_recipient(self, script: "Script",amount: "Amount"):
        raise NotImplementedError
    def add_unspendable(self, unspendable: "OutPoint"):
        raise NotImplementedError
    def add_utxo(self, outpoint: "OutPoint"):
        raise NotImplementedError
    def change_policy(self, change_policy: "ChangeSpendPolicy"):
        raise NotImplementedError
    def do_not_spend_change(self, ):
        raise NotImplementedError
    def drain_to(self, script: "Script"):
        raise NotImplementedError
    def drain_wallet(self, ):
        raise NotImplementedError
    def enable_rbf(self, ):
        raise NotImplementedError
    def enable_rbf_with_sequence(self, nsequence: "int"):
        raise NotImplementedError
    def fee_absolute(self, fee: "int"):
        raise NotImplementedError
    def fee_rate(self, fee_rate: "FeeRate"):
        raise NotImplementedError
    def finish(self, wallet: "Wallet"):
        raise NotImplementedError
    def manually_selected_only(self, ):
        raise NotImplementedError
    def only_spend_change(self, ):
        raise NotImplementedError
    def set_recipients(self, recipients: "typing.List[ScriptAmount]"):
        raise NotImplementedError
    def unspendable(self, unspendable: "typing.List[OutPoint]"):
        raise NotImplementedError

class TxBuilder:

    _pointer: ctypes.c_void_p
    def __init__(self, ):
        self._pointer = _rust_call(_UniffiLib.uniffi_bdkffi_fn_constructor_txbuilder_new,)

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_free_txbuilder, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_txbuilder, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def add_recipient(self, script: "Script",amount: "Amount") -> "TxBuilder":
        _UniffiConverterTypeScript.check_lower(script)
        
        _UniffiConverterTypeAmount.check_lower(amount)
        
        return _UniffiConverterTypeTxBuilder.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_add_recipient,self._uniffi_clone_pointer(),
        _UniffiConverterTypeScript.lower(script),
        _UniffiConverterTypeAmount.lower(amount))
        )






    def add_unspendable(self, unspendable: "OutPoint") -> "TxBuilder":
        _UniffiConverterTypeOutPoint.check_lower(unspendable)
        
        return _UniffiConverterTypeTxBuilder.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_add_unspendable,self._uniffi_clone_pointer(),
        _UniffiConverterTypeOutPoint.lower(unspendable))
        )






    def add_utxo(self, outpoint: "OutPoint") -> "TxBuilder":
        _UniffiConverterTypeOutPoint.check_lower(outpoint)
        
        return _UniffiConverterTypeTxBuilder.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_add_utxo,self._uniffi_clone_pointer(),
        _UniffiConverterTypeOutPoint.lower(outpoint))
        )






    def change_policy(self, change_policy: "ChangeSpendPolicy") -> "TxBuilder":
        _UniffiConverterTypeChangeSpendPolicy.check_lower(change_policy)
        
        return _UniffiConverterTypeTxBuilder.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_change_policy,self._uniffi_clone_pointer(),
        _UniffiConverterTypeChangeSpendPolicy.lower(change_policy))
        )






    def do_not_spend_change(self, ) -> "TxBuilder":
        return _UniffiConverterTypeTxBuilder.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_do_not_spend_change,self._uniffi_clone_pointer(),)
        )






    def drain_to(self, script: "Script") -> "TxBuilder":
        _UniffiConverterTypeScript.check_lower(script)
        
        return _UniffiConverterTypeTxBuilder.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_drain_to,self._uniffi_clone_pointer(),
        _UniffiConverterTypeScript.lower(script))
        )






    def drain_wallet(self, ) -> "TxBuilder":
        return _UniffiConverterTypeTxBuilder.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_drain_wallet,self._uniffi_clone_pointer(),)
        )






    def enable_rbf(self, ) -> "TxBuilder":
        return _UniffiConverterTypeTxBuilder.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_enable_rbf,self._uniffi_clone_pointer(),)
        )






    def enable_rbf_with_sequence(self, nsequence: "int") -> "TxBuilder":
        _UniffiConverterUInt32.check_lower(nsequence)
        
        return _UniffiConverterTypeTxBuilder.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_enable_rbf_with_sequence,self._uniffi_clone_pointer(),
        _UniffiConverterUInt32.lower(nsequence))
        )






    def fee_absolute(self, fee: "int") -> "TxBuilder":
        _UniffiConverterUInt64.check_lower(fee)
        
        return _UniffiConverterTypeTxBuilder.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_fee_absolute,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(fee))
        )






    def fee_rate(self, fee_rate: "FeeRate") -> "TxBuilder":
        _UniffiConverterTypeFeeRate.check_lower(fee_rate)
        
        return _UniffiConverterTypeTxBuilder.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_fee_rate,self._uniffi_clone_pointer(),
        _UniffiConverterTypeFeeRate.lower(fee_rate))
        )






    def finish(self, wallet: "Wallet") -> "Psbt":
        _UniffiConverterTypeWallet.check_lower(wallet)
        
        return _UniffiConverterTypePsbt.lift(
            _rust_call_with_error(
    _UniffiConverterTypeCreateTxError,_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_finish,self._uniffi_clone_pointer(),
        _UniffiConverterTypeWallet.lower(wallet))
        )






    def manually_selected_only(self, ) -> "TxBuilder":
        return _UniffiConverterTypeTxBuilder.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_manually_selected_only,self._uniffi_clone_pointer(),)
        )






    def only_spend_change(self, ) -> "TxBuilder":
        return _UniffiConverterTypeTxBuilder.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_only_spend_change,self._uniffi_clone_pointer(),)
        )






    def set_recipients(self, recipients: "typing.List[ScriptAmount]") -> "TxBuilder":
        _UniffiConverterSequenceTypeScriptAmount.check_lower(recipients)
        
        return _UniffiConverterTypeTxBuilder.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_set_recipients,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceTypeScriptAmount.lower(recipients))
        )






    def unspendable(self, unspendable: "typing.List[OutPoint]") -> "TxBuilder":
        _UniffiConverterSequenceTypeOutPoint.check_lower(unspendable)
        
        return _UniffiConverterTypeTxBuilder.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_unspendable,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceTypeOutPoint.lower(unspendable))
        )





class _UniffiConverterTypeTxBuilder:

    @staticmethod
    def lift(value: int):
        return TxBuilder._make_instance_(value)

    @staticmethod
    def check_lower(value: TxBuilder):
        if not isinstance(value, TxBuilder):
            raise TypeError("Expected TxBuilder instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: TxBuilderProtocol):
        if not isinstance(value, TxBuilder):
            raise TypeError("Expected TxBuilder instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: TxBuilderProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class UpdateProtocol(typing.Protocol):
    pass

class Update:

    _pointer: ctypes.c_void_p

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_free_update, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_update, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

class _UniffiConverterTypeUpdate:

    @staticmethod
    def lift(value: int):
        return Update._make_instance_(value)

    @staticmethod
    def check_lower(value: Update):
        if not isinstance(value, Update):
            raise TypeError("Expected Update instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: UpdateProtocol):
        if not isinstance(value, Update):
            raise TypeError("Expected Update instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: UpdateProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class WalletProtocol(typing.Protocol):
    def apply_update(self, update: "Update"):
        raise NotImplementedError
    def calculate_fee(self, tx: "Transaction"):
        raise NotImplementedError
    def calculate_fee_rate(self, tx: "Transaction"):
        raise NotImplementedError
    def commit(self, ):
        raise NotImplementedError
    def get_balance(self, ):
        raise NotImplementedError
    def get_tx(self, txid: "str"):
        raise NotImplementedError
    def is_mine(self, script: "Script"):
        raise NotImplementedError
    def list_output(self, ):
        raise NotImplementedError
    def list_unspent(self, ):
        raise NotImplementedError
    def network(self, ):
        raise NotImplementedError
    def reveal_next_address(self, keychain: "KeychainKind"):
        raise NotImplementedError
    def sent_and_received(self, tx: "Transaction"):
        raise NotImplementedError
    def sign(self, psbt: "Psbt"):
        raise NotImplementedError
    def start_full_scan(self, ):
        raise NotImplementedError
    def start_sync_with_revealed_spks(self, ):
        raise NotImplementedError
    def transactions(self, ):
        raise NotImplementedError

class Wallet:

    _pointer: ctypes.c_void_p
    def __init__(self, descriptor: "Descriptor",change_descriptor: "typing.Optional[Descriptor]",persistence_backend_path: "str",network: "Network"):
        _UniffiConverterTypeDescriptor.check_lower(descriptor)
        
        _UniffiConverterOptionalTypeDescriptor.check_lower(change_descriptor)
        
        _UniffiConverterString.check_lower(persistence_backend_path)
        
        _UniffiConverterTypeNetwork.check_lower(network)
        
        self._pointer = _rust_call_with_error(_UniffiConverterTypeWalletCreationError,_UniffiLib.uniffi_bdkffi_fn_constructor_wallet_new,
        _UniffiConverterTypeDescriptor.lower(descriptor),
        _UniffiConverterOptionalTypeDescriptor.lower(change_descriptor),
        _UniffiConverterString.lower(persistence_backend_path),
        _UniffiConverterTypeNetwork.lower(network))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_free_wallet, pointer)

    def _uniffi_clone_pointer(self):
        return _rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_wallet, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def new_no_persist(cls, descriptor: "Descriptor",change_descriptor: "typing.Optional[Descriptor]",network: "Network"):
        _UniffiConverterTypeDescriptor.check_lower(descriptor)
        
        _UniffiConverterOptionalTypeDescriptor.check_lower(change_descriptor)
        
        _UniffiConverterTypeNetwork.check_lower(network)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _rust_call_with_error(_UniffiConverterTypeDescriptorError,_UniffiLib.uniffi_bdkffi_fn_constructor_wallet_new_no_persist,
        _UniffiConverterTypeDescriptor.lower(descriptor),
        _UniffiConverterOptionalTypeDescriptor.lower(change_descriptor),
        _UniffiConverterTypeNetwork.lower(network))
        return cls._make_instance_(pointer)



    def apply_update(self, update: "Update"):
        _UniffiConverterTypeUpdate.check_lower(update)
        
        _rust_call_with_error(
    _UniffiConverterTypeCannotConnectError,_UniffiLib.uniffi_bdkffi_fn_method_wallet_apply_update,self._uniffi_clone_pointer(),
        _UniffiConverterTypeUpdate.lower(update))







    def calculate_fee(self, tx: "Transaction") -> "int":
        _UniffiConverterTypeTransaction.check_lower(tx)
        
        return _UniffiConverterUInt64.lift(
            _rust_call_with_error(
    _UniffiConverterTypeCalculateFeeError,_UniffiLib.uniffi_bdkffi_fn_method_wallet_calculate_fee,self._uniffi_clone_pointer(),
        _UniffiConverterTypeTransaction.lower(tx))
        )






    def calculate_fee_rate(self, tx: "Transaction") -> "FeeRate":
        _UniffiConverterTypeTransaction.check_lower(tx)
        
        return _UniffiConverterTypeFeeRate.lift(
            _rust_call_with_error(
    _UniffiConverterTypeCalculateFeeError,_UniffiLib.uniffi_bdkffi_fn_method_wallet_calculate_fee_rate,self._uniffi_clone_pointer(),
        _UniffiConverterTypeTransaction.lower(tx))
        )






    def commit(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _rust_call_with_error(
    _UniffiConverterTypePersistenceError,_UniffiLib.uniffi_bdkffi_fn_method_wallet_commit,self._uniffi_clone_pointer(),)
        )






    def get_balance(self, ) -> "Balance":
        return _UniffiConverterTypeBalance.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_wallet_get_balance,self._uniffi_clone_pointer(),)
        )






    def get_tx(self, txid: "str") -> "typing.Optional[CanonicalTx]":
        _UniffiConverterString.check_lower(txid)
        
        return _UniffiConverterOptionalTypeCanonicalTx.lift(
            _rust_call_with_error(
    _UniffiConverterTypeTxidParseError,_UniffiLib.uniffi_bdkffi_fn_method_wallet_get_tx,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(txid))
        )






    def is_mine(self, script: "Script") -> "bool":
        _UniffiConverterTypeScript.check_lower(script)
        
        return _UniffiConverterBool.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_wallet_is_mine,self._uniffi_clone_pointer(),
        _UniffiConverterTypeScript.lower(script))
        )






    def list_output(self, ) -> "typing.List[LocalOutput]":
        return _UniffiConverterSequenceTypeLocalOutput.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_wallet_list_output,self._uniffi_clone_pointer(),)
        )






    def list_unspent(self, ) -> "typing.List[LocalOutput]":
        return _UniffiConverterSequenceTypeLocalOutput.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_wallet_list_unspent,self._uniffi_clone_pointer(),)
        )






    def network(self, ) -> "Network":
        return _UniffiConverterTypeNetwork.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_wallet_network,self._uniffi_clone_pointer(),)
        )






    def reveal_next_address(self, keychain: "KeychainKind") -> "AddressInfo":
        _UniffiConverterTypeKeychainKind.check_lower(keychain)
        
        return _UniffiConverterTypeAddressInfo.lift(
            _rust_call_with_error(
    _UniffiConverterTypePersistenceError,_UniffiLib.uniffi_bdkffi_fn_method_wallet_reveal_next_address,self._uniffi_clone_pointer(),
        _UniffiConverterTypeKeychainKind.lower(keychain))
        )






    def sent_and_received(self, tx: "Transaction") -> "SentAndReceivedValues":
        _UniffiConverterTypeTransaction.check_lower(tx)
        
        return _UniffiConverterTypeSentAndReceivedValues.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_wallet_sent_and_received,self._uniffi_clone_pointer(),
        _UniffiConverterTypeTransaction.lower(tx))
        )






    def sign(self, psbt: "Psbt") -> "bool":
        _UniffiConverterTypePsbt.check_lower(psbt)
        
        return _UniffiConverterBool.lift(
            _rust_call_with_error(
    _UniffiConverterTypeSignerError,_UniffiLib.uniffi_bdkffi_fn_method_wallet_sign,self._uniffi_clone_pointer(),
        _UniffiConverterTypePsbt.lower(psbt))
        )






    def start_full_scan(self, ) -> "FullScanRequest":
        return _UniffiConverterTypeFullScanRequest.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_wallet_start_full_scan,self._uniffi_clone_pointer(),)
        )






    def start_sync_with_revealed_spks(self, ) -> "SyncRequest":
        return _UniffiConverterTypeSyncRequest.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_wallet_start_sync_with_revealed_spks,self._uniffi_clone_pointer(),)
        )






    def transactions(self, ) -> "typing.List[CanonicalTx]":
        return _UniffiConverterSequenceTypeCanonicalTx.lift(
            _rust_call(_UniffiLib.uniffi_bdkffi_fn_method_wallet_transactions,self._uniffi_clone_pointer(),)
        )





class _UniffiConverterTypeWallet:

    @staticmethod
    def lift(value: int):
        return Wallet._make_instance_(value)

    @staticmethod
    def check_lower(value: Wallet):
        if not isinstance(value, Wallet):
            raise TypeError("Expected Wallet instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: WalletProtocol):
        if not isinstance(value, Wallet):
            raise TypeError("Expected Wallet instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: WalletProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))


class AddressInfo:
    index: "int"
    address: "Address"
    keychain: "KeychainKind"
    @typing.no_type_check
    def __init__(self, index: "int", address: "Address", keychain: "KeychainKind"):
        self.index = index
        self.address = address
        self.keychain = keychain

    def __str__(self):
        return "AddressInfo(index={}, address={}, keychain={})".format(self.index, self.address, self.keychain)

    def __eq__(self, other):
        if self.index != other.index:
            return False
        if self.address != other.address:
            return False
        if self.keychain != other.keychain:
            return False
        return True

class _UniffiConverterTypeAddressInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AddressInfo(
            index=_UniffiConverterUInt32.read(buf),
            address=_UniffiConverterTypeAddress.read(buf),
            keychain=_UniffiConverterTypeKeychainKind.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt32.check_lower(value.index)
        _UniffiConverterTypeAddress.check_lower(value.address)
        _UniffiConverterTypeKeychainKind.check_lower(value.keychain)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt32.write(value.index, buf)
        _UniffiConverterTypeAddress.write(value.address, buf)
        _UniffiConverterTypeKeychainKind.write(value.keychain, buf)


class Balance:
    immature: "Amount"
    trusted_pending: "Amount"
    untrusted_pending: "Amount"
    confirmed: "Amount"
    trusted_spendable: "Amount"
    total: "Amount"
    @typing.no_type_check
    def __init__(self, immature: "Amount", trusted_pending: "Amount", untrusted_pending: "Amount", confirmed: "Amount", trusted_spendable: "Amount", total: "Amount"):
        self.immature = immature
        self.trusted_pending = trusted_pending
        self.untrusted_pending = untrusted_pending
        self.confirmed = confirmed
        self.trusted_spendable = trusted_spendable
        self.total = total

    def __str__(self):
        return "Balance(immature={}, trusted_pending={}, untrusted_pending={}, confirmed={}, trusted_spendable={}, total={})".format(self.immature, self.trusted_pending, self.untrusted_pending, self.confirmed, self.trusted_spendable, self.total)

    def __eq__(self, other):
        if self.immature != other.immature:
            return False
        if self.trusted_pending != other.trusted_pending:
            return False
        if self.untrusted_pending != other.untrusted_pending:
            return False
        if self.confirmed != other.confirmed:
            return False
        if self.trusted_spendable != other.trusted_spendable:
            return False
        if self.total != other.total:
            return False
        return True

class _UniffiConverterTypeBalance(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Balance(
            immature=_UniffiConverterTypeAmount.read(buf),
            trusted_pending=_UniffiConverterTypeAmount.read(buf),
            untrusted_pending=_UniffiConverterTypeAmount.read(buf),
            confirmed=_UniffiConverterTypeAmount.read(buf),
            trusted_spendable=_UniffiConverterTypeAmount.read(buf),
            total=_UniffiConverterTypeAmount.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeAmount.check_lower(value.immature)
        _UniffiConverterTypeAmount.check_lower(value.trusted_pending)
        _UniffiConverterTypeAmount.check_lower(value.untrusted_pending)
        _UniffiConverterTypeAmount.check_lower(value.confirmed)
        _UniffiConverterTypeAmount.check_lower(value.trusted_spendable)
        _UniffiConverterTypeAmount.check_lower(value.total)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeAmount.write(value.immature, buf)
        _UniffiConverterTypeAmount.write(value.trusted_pending, buf)
        _UniffiConverterTypeAmount.write(value.untrusted_pending, buf)
        _UniffiConverterTypeAmount.write(value.confirmed, buf)
        _UniffiConverterTypeAmount.write(value.trusted_spendable, buf)
        _UniffiConverterTypeAmount.write(value.total, buf)


class CanonicalTx:
    transaction: "Transaction"
    chain_position: "ChainPosition"
    @typing.no_type_check
    def __init__(self, transaction: "Transaction", chain_position: "ChainPosition"):
        self.transaction = transaction
        self.chain_position = chain_position

    def __str__(self):
        return "CanonicalTx(transaction={}, chain_position={})".format(self.transaction, self.chain_position)

    def __eq__(self, other):
        if self.transaction != other.transaction:
            return False
        if self.chain_position != other.chain_position:
            return False
        return True

class _UniffiConverterTypeCanonicalTx(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CanonicalTx(
            transaction=_UniffiConverterTypeTransaction.read(buf),
            chain_position=_UniffiConverterTypeChainPosition.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeTransaction.check_lower(value.transaction)
        _UniffiConverterTypeChainPosition.check_lower(value.chain_position)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeTransaction.write(value.transaction, buf)
        _UniffiConverterTypeChainPosition.write(value.chain_position, buf)


class LocalOutput:
    outpoint: "OutPoint"
    txout: "TxOut"
    keychain: "KeychainKind"
    is_spent: "bool"
    @typing.no_type_check
    def __init__(self, outpoint: "OutPoint", txout: "TxOut", keychain: "KeychainKind", is_spent: "bool"):
        self.outpoint = outpoint
        self.txout = txout
        self.keychain = keychain
        self.is_spent = is_spent

    def __str__(self):
        return "LocalOutput(outpoint={}, txout={}, keychain={}, is_spent={})".format(self.outpoint, self.txout, self.keychain, self.is_spent)

    def __eq__(self, other):
        if self.outpoint != other.outpoint:
            return False
        if self.txout != other.txout:
            return False
        if self.keychain != other.keychain:
            return False
        if self.is_spent != other.is_spent:
            return False
        return True

class _UniffiConverterTypeLocalOutput(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LocalOutput(
            outpoint=_UniffiConverterTypeOutPoint.read(buf),
            txout=_UniffiConverterTypeTxOut.read(buf),
            keychain=_UniffiConverterTypeKeychainKind.read(buf),
            is_spent=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeOutPoint.check_lower(value.outpoint)
        _UniffiConverterTypeTxOut.check_lower(value.txout)
        _UniffiConverterTypeKeychainKind.check_lower(value.keychain)
        _UniffiConverterBool.check_lower(value.is_spent)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeOutPoint.write(value.outpoint, buf)
        _UniffiConverterTypeTxOut.write(value.txout, buf)
        _UniffiConverterTypeKeychainKind.write(value.keychain, buf)
        _UniffiConverterBool.write(value.is_spent, buf)


class OutPoint:
    txid: "str"
    vout: "int"
    @typing.no_type_check
    def __init__(self, txid: "str", vout: "int"):
        self.txid = txid
        self.vout = vout

    def __str__(self):
        return "OutPoint(txid={}, vout={})".format(self.txid, self.vout)

    def __eq__(self, other):
        if self.txid != other.txid:
            return False
        if self.vout != other.vout:
            return False
        return True

class _UniffiConverterTypeOutPoint(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return OutPoint(
            txid=_UniffiConverterString.read(buf),
            vout=_UniffiConverterUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.txid)
        _UniffiConverterUInt32.check_lower(value.vout)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.txid, buf)
        _UniffiConverterUInt32.write(value.vout, buf)


class ScriptAmount:
    script: "Script"
    amount: "Amount"
    @typing.no_type_check
    def __init__(self, script: "Script", amount: "Amount"):
        self.script = script
        self.amount = amount

    def __str__(self):
        return "ScriptAmount(script={}, amount={})".format(self.script, self.amount)

    def __eq__(self, other):
        if self.script != other.script:
            return False
        if self.amount != other.amount:
            return False
        return True

class _UniffiConverterTypeScriptAmount(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ScriptAmount(
            script=_UniffiConverterTypeScript.read(buf),
            amount=_UniffiConverterTypeAmount.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeScript.check_lower(value.script)
        _UniffiConverterTypeAmount.check_lower(value.amount)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeScript.write(value.script, buf)
        _UniffiConverterTypeAmount.write(value.amount, buf)


class SentAndReceivedValues:
    sent: "Amount"
    received: "Amount"
    @typing.no_type_check
    def __init__(self, sent: "Amount", received: "Amount"):
        self.sent = sent
        self.received = received

    def __str__(self):
        return "SentAndReceivedValues(sent={}, received={})".format(self.sent, self.received)

    def __eq__(self, other):
        if self.sent != other.sent:
            return False
        if self.received != other.received:
            return False
        return True

class _UniffiConverterTypeSentAndReceivedValues(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SentAndReceivedValues(
            sent=_UniffiConverterTypeAmount.read(buf),
            received=_UniffiConverterTypeAmount.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeAmount.check_lower(value.sent)
        _UniffiConverterTypeAmount.check_lower(value.received)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeAmount.write(value.sent, buf)
        _UniffiConverterTypeAmount.write(value.received, buf)


class TxIn:
    previous_output: "OutPoint"
    script_sig: "Script"
    sequence: "int"
    witness: "typing.List[typing.List[int]]"
    @typing.no_type_check
    def __init__(self, previous_output: "OutPoint", script_sig: "Script", sequence: "int", witness: "typing.List[typing.List[int]]"):
        self.previous_output = previous_output
        self.script_sig = script_sig
        self.sequence = sequence
        self.witness = witness

    def __str__(self):
        return "TxIn(previous_output={}, script_sig={}, sequence={}, witness={})".format(self.previous_output, self.script_sig, self.sequence, self.witness)

    def __eq__(self, other):
        if self.previous_output != other.previous_output:
            return False
        if self.script_sig != other.script_sig:
            return False
        if self.sequence != other.sequence:
            return False
        if self.witness != other.witness:
            return False
        return True

class _UniffiConverterTypeTxIn(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TxIn(
            previous_output=_UniffiConverterTypeOutPoint.read(buf),
            script_sig=_UniffiConverterTypeScript.read(buf),
            sequence=_UniffiConverterUInt32.read(buf),
            witness=_UniffiConverterSequenceSequenceUInt8.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeOutPoint.check_lower(value.previous_output)
        _UniffiConverterTypeScript.check_lower(value.script_sig)
        _UniffiConverterUInt32.check_lower(value.sequence)
        _UniffiConverterSequenceSequenceUInt8.check_lower(value.witness)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeOutPoint.write(value.previous_output, buf)
        _UniffiConverterTypeScript.write(value.script_sig, buf)
        _UniffiConverterUInt32.write(value.sequence, buf)
        _UniffiConverterSequenceSequenceUInt8.write(value.witness, buf)


class TxOut:
    value: "int"
    script_pubkey: "Script"
    @typing.no_type_check
    def __init__(self, value: "int", script_pubkey: "Script"):
        self.value = value
        self.script_pubkey = script_pubkey

    def __str__(self):
        return "TxOut(value={}, script_pubkey={})".format(self.value, self.script_pubkey)

    def __eq__(self, other):
        if self.value != other.value:
            return False
        if self.script_pubkey != other.script_pubkey:
            return False
        return True

class _UniffiConverterTypeTxOut(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TxOut(
            value=_UniffiConverterUInt64.read(buf),
            script_pubkey=_UniffiConverterTypeScript.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.value)
        _UniffiConverterTypeScript.check_lower(value.script_pubkey)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.value, buf)
        _UniffiConverterTypeScript.write(value.script_pubkey, buf)


# AddressError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class AddressError(Exception):
    pass

_UniffiTempAddressError = AddressError

class AddressError:  # type: ignore
    class Base58(_UniffiTempAddressError):

        def __init__(self):
            pass
        def __repr__(self):
            return "AddressError.Base58({})".format(str(self))
    _UniffiTempAddressError.Base58 = Base58 # type: ignore
    class Bech32(_UniffiTempAddressError):

        def __init__(self):
            pass
        def __repr__(self):
            return "AddressError.Bech32({})".format(str(self))
    _UniffiTempAddressError.Bech32 = Bech32 # type: ignore
    class WitnessVersion(_UniffiTempAddressError):

        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message
        def __repr__(self):
            return "AddressError.WitnessVersion({})".format(str(self))
    _UniffiTempAddressError.WitnessVersion = WitnessVersion # type: ignore
    class WitnessProgram(_UniffiTempAddressError):

        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message
        def __repr__(self):
            return "AddressError.WitnessProgram({})".format(str(self))
    _UniffiTempAddressError.WitnessProgram = WitnessProgram # type: ignore
    class UncompressedPubkey(_UniffiTempAddressError):

        def __init__(self):
            pass
        def __repr__(self):
            return "AddressError.UncompressedPubkey({})".format(str(self))
    _UniffiTempAddressError.UncompressedPubkey = UncompressedPubkey # type: ignore
    class ExcessiveScriptSize(_UniffiTempAddressError):

        def __init__(self):
            pass
        def __repr__(self):
            return "AddressError.ExcessiveScriptSize({})".format(str(self))
    _UniffiTempAddressError.ExcessiveScriptSize = ExcessiveScriptSize # type: ignore
    class UnrecognizedScript(_UniffiTempAddressError):

        def __init__(self):
            pass
        def __repr__(self):
            return "AddressError.UnrecognizedScript({})".format(str(self))
    _UniffiTempAddressError.UnrecognizedScript = UnrecognizedScript # type: ignore
    class NetworkValidation(_UniffiTempAddressError):

        def __init__(self, required, found, address):
            super().__init__(", ".join([
                "required={!r}".format(required),
                "found={!r}".format(found),
                "address={!r}".format(address),
            ]))
            self.required = required
            self.found = found
            self.address = address
        def __repr__(self):
            return "AddressError.NetworkValidation({})".format(str(self))
    _UniffiTempAddressError.NetworkValidation = NetworkValidation # type: ignore
    class OtherAddressErr(_UniffiTempAddressError):

        def __init__(self):
            pass
        def __repr__(self):
            return "AddressError.OtherAddressErr({})".format(str(self))
    _UniffiTempAddressError.OtherAddressErr = OtherAddressErr # type: ignore

AddressError = _UniffiTempAddressError # type: ignore
del _UniffiTempAddressError


class _UniffiConverterTypeAddressError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return AddressError.Base58(
            )
        if variant == 2:
            return AddressError.Bech32(
            )
        if variant == 3:
            return AddressError.WitnessVersion(
                error_message=_UniffiConverterString.read(buf),
            )
        if variant == 4:
            return AddressError.WitnessProgram(
                error_message=_UniffiConverterString.read(buf),
            )
        if variant == 5:
            return AddressError.UncompressedPubkey(
            )
        if variant == 6:
            return AddressError.ExcessiveScriptSize(
            )
        if variant == 7:
            return AddressError.UnrecognizedScript(
            )
        if variant == 8:
            return AddressError.NetworkValidation(
                required=_UniffiConverterTypeNetwork.read(buf),
                found=_UniffiConverterTypeNetwork.read(buf),
                address=_UniffiConverterString.read(buf),
            )
        if variant == 9:
            return AddressError.OtherAddressErr(
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, AddressError.Base58):
            return
        if isinstance(value, AddressError.Bech32):
            return
        if isinstance(value, AddressError.WitnessVersion):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, AddressError.WitnessProgram):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, AddressError.UncompressedPubkey):
            return
        if isinstance(value, AddressError.ExcessiveScriptSize):
            return
        if isinstance(value, AddressError.UnrecognizedScript):
            return
        if isinstance(value, AddressError.NetworkValidation):
            _UniffiConverterTypeNetwork.check_lower(value.required)
            _UniffiConverterTypeNetwork.check_lower(value.found)
            _UniffiConverterString.check_lower(value.address)
            return
        if isinstance(value, AddressError.OtherAddressErr):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, AddressError.Base58):
            buf.write_i32(1)
        if isinstance(value, AddressError.Bech32):
            buf.write_i32(2)
        if isinstance(value, AddressError.WitnessVersion):
            buf.write_i32(3)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, AddressError.WitnessProgram):
            buf.write_i32(4)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, AddressError.UncompressedPubkey):
            buf.write_i32(5)
        if isinstance(value, AddressError.ExcessiveScriptSize):
            buf.write_i32(6)
        if isinstance(value, AddressError.UnrecognizedScript):
            buf.write_i32(7)
        if isinstance(value, AddressError.NetworkValidation):
            buf.write_i32(8)
            _UniffiConverterTypeNetwork.write(value.required, buf)
            _UniffiConverterTypeNetwork.write(value.found, buf)
            _UniffiConverterString.write(value.address, buf)
        if isinstance(value, AddressError.OtherAddressErr):
            buf.write_i32(9)


# Bip32Error
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class Bip32Error(Exception):
    pass

_UniffiTempBip32Error = Bip32Error

class Bip32Error:  # type: ignore
    class CannotDeriveFromHardenedKey(_UniffiTempBip32Error):

        def __init__(self):
            pass
        def __repr__(self):
            return "Bip32Error.CannotDeriveFromHardenedKey({})".format(str(self))
    _UniffiTempBip32Error.CannotDeriveFromHardenedKey = CannotDeriveFromHardenedKey # type: ignore
    class Secp256k1(_UniffiTempBip32Error):

        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message
        def __repr__(self):
            return "Bip32Error.Secp256k1({})".format(str(self))
    _UniffiTempBip32Error.Secp256k1 = Secp256k1 # type: ignore
    class InvalidChildNumber(_UniffiTempBip32Error):

        def __init__(self, child_number):
            super().__init__(", ".join([
                "child_number={!r}".format(child_number),
            ]))
            self.child_number = child_number
        def __repr__(self):
            return "Bip32Error.InvalidChildNumber({})".format(str(self))
    _UniffiTempBip32Error.InvalidChildNumber = InvalidChildNumber # type: ignore
    class InvalidChildNumberFormat(_UniffiTempBip32Error):

        def __init__(self):
            pass
        def __repr__(self):
            return "Bip32Error.InvalidChildNumberFormat({})".format(str(self))
    _UniffiTempBip32Error.InvalidChildNumberFormat = InvalidChildNumberFormat # type: ignore
    class InvalidDerivationPathFormat(_UniffiTempBip32Error):

        def __init__(self):
            pass
        def __repr__(self):
            return "Bip32Error.InvalidDerivationPathFormat({})".format(str(self))
    _UniffiTempBip32Error.InvalidDerivationPathFormat = InvalidDerivationPathFormat # type: ignore
    class UnknownVersion(_UniffiTempBip32Error):

        def __init__(self, version):
            super().__init__(", ".join([
                "version={!r}".format(version),
            ]))
            self.version = version
        def __repr__(self):
            return "Bip32Error.UnknownVersion({})".format(str(self))
    _UniffiTempBip32Error.UnknownVersion = UnknownVersion # type: ignore
    class WrongExtendedKeyLength(_UniffiTempBip32Error):

        def __init__(self, length):
            super().__init__(", ".join([
                "length={!r}".format(length),
            ]))
            self.length = length
        def __repr__(self):
            return "Bip32Error.WrongExtendedKeyLength({})".format(str(self))
    _UniffiTempBip32Error.WrongExtendedKeyLength = WrongExtendedKeyLength # type: ignore
    class Base58(_UniffiTempBip32Error):

        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message
        def __repr__(self):
            return "Bip32Error.Base58({})".format(str(self))
    _UniffiTempBip32Error.Base58 = Base58 # type: ignore
    class Hex(_UniffiTempBip32Error):

        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message
        def __repr__(self):
            return "Bip32Error.Hex({})".format(str(self))
    _UniffiTempBip32Error.Hex = Hex # type: ignore
    class InvalidPublicKeyHexLength(_UniffiTempBip32Error):

        def __init__(self, length):
            super().__init__(", ".join([
                "length={!r}".format(length),
            ]))
            self.length = length
        def __repr__(self):
            return "Bip32Error.InvalidPublicKeyHexLength({})".format(str(self))
    _UniffiTempBip32Error.InvalidPublicKeyHexLength = InvalidPublicKeyHexLength # type: ignore
    class UnknownError(_UniffiTempBip32Error):

        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message
        def __repr__(self):
            return "Bip32Error.UnknownError({})".format(str(self))
    _UniffiTempBip32Error.UnknownError = UnknownError # type: ignore

Bip32Error = _UniffiTempBip32Error # type: ignore
del _UniffiTempBip32Error


class _UniffiConverterTypeBip32Error(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Bip32Error.CannotDeriveFromHardenedKey(
            )
        if variant == 2:
            return Bip32Error.Secp256k1(
                error_message=_UniffiConverterString.read(buf),
            )
        if variant == 3:
            return Bip32Error.InvalidChildNumber(
                child_number=_UniffiConverterUInt32.read(buf),
            )
        if variant == 4:
            return Bip32Error.InvalidChildNumberFormat(
            )
        if variant == 5:
            return Bip32Error.InvalidDerivationPathFormat(
            )
        if variant == 6:
            return Bip32Error.UnknownVersion(
                version=_UniffiConverterString.read(buf),
            )
        if variant == 7:
            return Bip32Error.WrongExtendedKeyLength(
                length=_UniffiConverterUInt32.read(buf),
            )
        if variant == 8:
            return Bip32Error.Base58(
                error_message=_UniffiConverterString.read(buf),
            )
        if variant == 9:
            return Bip32Error.Hex(
                error_message=_UniffiConverterString.read(buf),
            )
        if variant == 10:
            return Bip32Error.InvalidPublicKeyHexLength(
                length=_UniffiConverterUInt32.read(buf),
            )
        if variant == 11:
            return Bip32Error.UnknownError(
                error_message=_UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, Bip32Error.CannotDeriveFromHardenedKey):
            return
        if isinstance(value, Bip32Error.Secp256k1):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, Bip32Error.InvalidChildNumber):
            _UniffiConverterUInt32.check_lower(value.child_number)
            return
        if isinstance(value, Bip32Error.InvalidChildNumberFormat):
            return
        if isinstance(value, Bip32Error.InvalidDerivationPathFormat):
            return
        if isinstance(value, Bip32Error.UnknownVersion):
            _UniffiConverterString.check_lower(value.version)
            return
        if isinstance(value, Bip32Error.WrongExtendedKeyLength):
            _UniffiConverterUInt32.check_lower(value.length)
            return
        if isinstance(value, Bip32Error.Base58):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, Bip32Error.Hex):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, Bip32Error.InvalidPublicKeyHexLength):
            _UniffiConverterUInt32.check_lower(value.length)
            return
        if isinstance(value, Bip32Error.UnknownError):
            _UniffiConverterString.check_lower(value.error_message)
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, Bip32Error.CannotDeriveFromHardenedKey):
            buf.write_i32(1)
        if isinstance(value, Bip32Error.Secp256k1):
            buf.write_i32(2)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, Bip32Error.InvalidChildNumber):
            buf.write_i32(3)
            _UniffiConverterUInt32.write(value.child_number, buf)
        if isinstance(value, Bip32Error.InvalidChildNumberFormat):
            buf.write_i32(4)
        if isinstance(value, Bip32Error.InvalidDerivationPathFormat):
            buf.write_i32(5)
        if isinstance(value, Bip32Error.UnknownVersion):
            buf.write_i32(6)
            _UniffiConverterString.write(value.version, buf)
        if isinstance(value, Bip32Error.WrongExtendedKeyLength):
            buf.write_i32(7)
            _UniffiConverterUInt32.write(value.length, buf)
        if isinstance(value, Bip32Error.Base58):
            buf.write_i32(8)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, Bip32Error.Hex):
            buf.write_i32(9)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, Bip32Error.InvalidPublicKeyHexLength):
            buf.write_i32(10)
            _UniffiConverterUInt32.write(value.length, buf)
        if isinstance(value, Bip32Error.UnknownError):
            buf.write_i32(11)
            _UniffiConverterString.write(value.error_message, buf)


# Bip39Error
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class Bip39Error(Exception):
    pass

_UniffiTempBip39Error = Bip39Error

class Bip39Error:  # type: ignore
    class BadWordCount(_UniffiTempBip39Error):

        def __init__(self, word_count):
            super().__init__(", ".join([
                "word_count={!r}".format(word_count),
            ]))
            self.word_count = word_count
        def __repr__(self):
            return "Bip39Error.BadWordCount({})".format(str(self))
    _UniffiTempBip39Error.BadWordCount = BadWordCount # type: ignore
    class UnknownWord(_UniffiTempBip39Error):

        def __init__(self, index):
            super().__init__(", ".join([
                "index={!r}".format(index),
            ]))
            self.index = index
        def __repr__(self):
            return "Bip39Error.UnknownWord({})".format(str(self))
    _UniffiTempBip39Error.UnknownWord = UnknownWord # type: ignore
    class BadEntropyBitCount(_UniffiTempBip39Error):

        def __init__(self, bit_count):
            super().__init__(", ".join([
                "bit_count={!r}".format(bit_count),
            ]))
            self.bit_count = bit_count
        def __repr__(self):
            return "Bip39Error.BadEntropyBitCount({})".format(str(self))
    _UniffiTempBip39Error.BadEntropyBitCount = BadEntropyBitCount # type: ignore
    class InvalidChecksum(_UniffiTempBip39Error):

        def __init__(self):
            pass
        def __repr__(self):
            return "Bip39Error.InvalidChecksum({})".format(str(self))
    _UniffiTempBip39Error.InvalidChecksum = InvalidChecksum # type: ignore
    class AmbiguousLanguages(_UniffiTempBip39Error):

        def __init__(self, languages):
            super().__init__(", ".join([
                "languages={!r}".format(languages),
            ]))
            self.languages = languages
        def __repr__(self):
            return "Bip39Error.AmbiguousLanguages({})".format(str(self))
    _UniffiTempBip39Error.AmbiguousLanguages = AmbiguousLanguages # type: ignore

Bip39Error = _UniffiTempBip39Error # type: ignore
del _UniffiTempBip39Error


class _UniffiConverterTypeBip39Error(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Bip39Error.BadWordCount(
                word_count=_UniffiConverterUInt64.read(buf),
            )
        if variant == 2:
            return Bip39Error.UnknownWord(
                index=_UniffiConverterUInt64.read(buf),
            )
        if variant == 3:
            return Bip39Error.BadEntropyBitCount(
                bit_count=_UniffiConverterUInt64.read(buf),
            )
        if variant == 4:
            return Bip39Error.InvalidChecksum(
            )
        if variant == 5:
            return Bip39Error.AmbiguousLanguages(
                languages=_UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, Bip39Error.BadWordCount):
            _UniffiConverterUInt64.check_lower(value.word_count)
            return
        if isinstance(value, Bip39Error.UnknownWord):
            _UniffiConverterUInt64.check_lower(value.index)
            return
        if isinstance(value, Bip39Error.BadEntropyBitCount):
            _UniffiConverterUInt64.check_lower(value.bit_count)
            return
        if isinstance(value, Bip39Error.InvalidChecksum):
            return
        if isinstance(value, Bip39Error.AmbiguousLanguages):
            _UniffiConverterString.check_lower(value.languages)
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, Bip39Error.BadWordCount):
            buf.write_i32(1)
            _UniffiConverterUInt64.write(value.word_count, buf)
        if isinstance(value, Bip39Error.UnknownWord):
            buf.write_i32(2)
            _UniffiConverterUInt64.write(value.index, buf)
        if isinstance(value, Bip39Error.BadEntropyBitCount):
            buf.write_i32(3)
            _UniffiConverterUInt64.write(value.bit_count, buf)
        if isinstance(value, Bip39Error.InvalidChecksum):
            buf.write_i32(4)
        if isinstance(value, Bip39Error.AmbiguousLanguages):
            buf.write_i32(5)
            _UniffiConverterString.write(value.languages, buf)


# CalculateFeeError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class CalculateFeeError(Exception):
    pass

_UniffiTempCalculateFeeError = CalculateFeeError

class CalculateFeeError:  # type: ignore
    class MissingTxOut(_UniffiTempCalculateFeeError):

        def __init__(self, out_points):
            super().__init__(", ".join([
                "out_points={!r}".format(out_points),
            ]))
            self.out_points = out_points
        def __repr__(self):
            return "CalculateFeeError.MissingTxOut({})".format(str(self))
    _UniffiTempCalculateFeeError.MissingTxOut = MissingTxOut # type: ignore
    class NegativeFee(_UniffiTempCalculateFeeError):

        def __init__(self, fee):
            super().__init__(", ".join([
                "fee={!r}".format(fee),
            ]))
            self.fee = fee
        def __repr__(self):
            return "CalculateFeeError.NegativeFee({})".format(str(self))
    _UniffiTempCalculateFeeError.NegativeFee = NegativeFee # type: ignore

CalculateFeeError = _UniffiTempCalculateFeeError # type: ignore
del _UniffiTempCalculateFeeError


class _UniffiConverterTypeCalculateFeeError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return CalculateFeeError.MissingTxOut(
                out_points=_UniffiConverterSequenceTypeOutPoint.read(buf),
            )
        if variant == 2:
            return CalculateFeeError.NegativeFee(
                fee=_UniffiConverterInt64.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, CalculateFeeError.MissingTxOut):
            _UniffiConverterSequenceTypeOutPoint.check_lower(value.out_points)
            return
        if isinstance(value, CalculateFeeError.NegativeFee):
            _UniffiConverterInt64.check_lower(value.fee)
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, CalculateFeeError.MissingTxOut):
            buf.write_i32(1)
            _UniffiConverterSequenceTypeOutPoint.write(value.out_points, buf)
        if isinstance(value, CalculateFeeError.NegativeFee):
            buf.write_i32(2)
            _UniffiConverterInt64.write(value.fee, buf)


# CannotConnectError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class CannotConnectError(Exception):
    pass

_UniffiTempCannotConnectError = CannotConnectError

class CannotConnectError:  # type: ignore
    class Include(_UniffiTempCannotConnectError):

        def __init__(self, height):
            super().__init__(", ".join([
                "height={!r}".format(height),
            ]))
            self.height = height
        def __repr__(self):
            return "CannotConnectError.Include({})".format(str(self))
    _UniffiTempCannotConnectError.Include = Include # type: ignore

CannotConnectError = _UniffiTempCannotConnectError # type: ignore
del _UniffiTempCannotConnectError


class _UniffiConverterTypeCannotConnectError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return CannotConnectError.Include(
                height=_UniffiConverterUInt32.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, CannotConnectError.Include):
            _UniffiConverterUInt32.check_lower(value.height)
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, CannotConnectError.Include):
            buf.write_i32(1)
            _UniffiConverterUInt32.write(value.height, buf)





class ChainPosition:
    def __init__(self):
        raise RuntimeError("ChainPosition cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class CONFIRMED:
        height: "int"
        timestamp: "int"

        @typing.no_type_check
        def __init__(self,height: "int", timestamp: "int"):
            
            self.height = height
            self.timestamp = timestamp
            

        def __str__(self):
            return "ChainPosition.CONFIRMED(height={}, timestamp={})".format(self.height, self.timestamp)

        def __eq__(self, other):
            if not other.is_confirmed():
                return False
            if self.height != other.height:
                return False
            if self.timestamp != other.timestamp:
                return False
            return True
    class UNCONFIRMED:
        timestamp: "int"

        @typing.no_type_check
        def __init__(self,timestamp: "int"):
            
            self.timestamp = timestamp
            

        def __str__(self):
            return "ChainPosition.UNCONFIRMED(timestamp={})".format(self.timestamp)

        def __eq__(self, other):
            if not other.is_unconfirmed():
                return False
            if self.timestamp != other.timestamp:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_confirmed(self) -> bool:
        return isinstance(self, ChainPosition.CONFIRMED)
    def is_unconfirmed(self) -> bool:
        return isinstance(self, ChainPosition.UNCONFIRMED)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ChainPosition.CONFIRMED = type("ChainPosition.CONFIRMED", (ChainPosition.CONFIRMED, ChainPosition,), {})  # type: ignore
ChainPosition.UNCONFIRMED = type("ChainPosition.UNCONFIRMED", (ChainPosition.UNCONFIRMED, ChainPosition,), {})  # type: ignore




class _UniffiConverterTypeChainPosition(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ChainPosition.CONFIRMED(
                _UniffiConverterUInt32.read(buf),
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 2:
            return ChainPosition.UNCONFIRMED(
                _UniffiConverterUInt64.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_confirmed():
            _UniffiConverterUInt32.check_lower(value.height)
            _UniffiConverterUInt64.check_lower(value.timestamp)
            return
        if value.is_unconfirmed():
            _UniffiConverterUInt64.check_lower(value.timestamp)
            return

    @staticmethod
    def write(value, buf):
        if value.is_confirmed():
            buf.write_i32(1)
            _UniffiConverterUInt32.write(value.height, buf)
            _UniffiConverterUInt64.write(value.timestamp, buf)
        if value.is_unconfirmed():
            buf.write_i32(2)
            _UniffiConverterUInt64.write(value.timestamp, buf)







class ChangeSpendPolicy(enum.Enum):
    CHANGE_ALLOWED = 0
    
    ONLY_CHANGE = 1
    
    CHANGE_FORBIDDEN = 2
    


class _UniffiConverterTypeChangeSpendPolicy(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ChangeSpendPolicy.CHANGE_ALLOWED
        if variant == 2:
            return ChangeSpendPolicy.ONLY_CHANGE
        if variant == 3:
            return ChangeSpendPolicy.CHANGE_FORBIDDEN
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == ChangeSpendPolicy.CHANGE_ALLOWED:
            return
        if value == ChangeSpendPolicy.ONLY_CHANGE:
            return
        if value == ChangeSpendPolicy.CHANGE_FORBIDDEN:
            return

    @staticmethod
    def write(value, buf):
        if value == ChangeSpendPolicy.CHANGE_ALLOWED:
            buf.write_i32(1)
        if value == ChangeSpendPolicy.ONLY_CHANGE:
            buf.write_i32(2)
        if value == ChangeSpendPolicy.CHANGE_FORBIDDEN:
            buf.write_i32(3)




# CreateTxError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class CreateTxError(Exception):
    pass

_UniffiTempCreateTxError = CreateTxError

class CreateTxError:  # type: ignore
    class Descriptor(_UniffiTempCreateTxError):

        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message
        def __repr__(self):
            return "CreateTxError.Descriptor({})".format(str(self))
    _UniffiTempCreateTxError.Descriptor = Descriptor # type: ignore
    class Persist(_UniffiTempCreateTxError):

        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message
        def __repr__(self):
            return "CreateTxError.Persist({})".format(str(self))
    _UniffiTempCreateTxError.Persist = Persist # type: ignore
    class Policy(_UniffiTempCreateTxError):

        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message
        def __repr__(self):
            return "CreateTxError.Policy({})".format(str(self))
    _UniffiTempCreateTxError.Policy = Policy # type: ignore
    class SpendingPolicyRequired(_UniffiTempCreateTxError):

        def __init__(self, kind):
            super().__init__(", ".join([
                "kind={!r}".format(kind),
            ]))
            self.kind = kind
        def __repr__(self):
            return "CreateTxError.SpendingPolicyRequired({})".format(str(self))
    _UniffiTempCreateTxError.SpendingPolicyRequired = SpendingPolicyRequired # type: ignore
    class Version0(_UniffiTempCreateTxError):

        def __init__(self):
            pass
        def __repr__(self):
            return "CreateTxError.Version0({})".format(str(self))
    _UniffiTempCreateTxError.Version0 = Version0 # type: ignore
    class Version1Csv(_UniffiTempCreateTxError):

        def __init__(self):
            pass
        def __repr__(self):
            return "CreateTxError.Version1Csv({})".format(str(self))
    _UniffiTempCreateTxError.Version1Csv = Version1Csv # type: ignore
    class LockTime(_UniffiTempCreateTxError):

        def __init__(self, requested, required):
            super().__init__(", ".join([
                "requested={!r}".format(requested),
                "required={!r}".format(required),
            ]))
            self.requested = requested
            self.required = required
        def __repr__(self):
            return "CreateTxError.LockTime({})".format(str(self))
    _UniffiTempCreateTxError.LockTime = LockTime # type: ignore
    class RbfSequence(_UniffiTempCreateTxError):

        def __init__(self):
            pass
        def __repr__(self):
            return "CreateTxError.RbfSequence({})".format(str(self))
    _UniffiTempCreateTxError.RbfSequence = RbfSequence # type: ignore
    class RbfSequenceCsv(_UniffiTempCreateTxError):

        def __init__(self, rbf, csv):
            super().__init__(", ".join([
                "rbf={!r}".format(rbf),
                "csv={!r}".format(csv),
            ]))
            self.rbf = rbf
            self.csv = csv
        def __repr__(self):
            return "CreateTxError.RbfSequenceCsv({})".format(str(self))
    _UniffiTempCreateTxError.RbfSequenceCsv = RbfSequenceCsv # type: ignore
    class FeeTooLow(_UniffiTempCreateTxError):

        def __init__(self, required):
            super().__init__(", ".join([
                "required={!r}".format(required),
            ]))
            self.required = required
        def __repr__(self):
            return "CreateTxError.FeeTooLow({})".format(str(self))
    _UniffiTempCreateTxError.FeeTooLow = FeeTooLow # type: ignore
    class FeeRateTooLow(_UniffiTempCreateTxError):

        def __init__(self, required):
            super().__init__(", ".join([
                "required={!r}".format(required),
            ]))
            self.required = required
        def __repr__(self):
            return "CreateTxError.FeeRateTooLow({})".format(str(self))
    _UniffiTempCreateTxError.FeeRateTooLow = FeeRateTooLow # type: ignore
    class NoUtxosSelected(_UniffiTempCreateTxError):

        def __init__(self):
            pass
        def __repr__(self):
            return "CreateTxError.NoUtxosSelected({})".format(str(self))
    _UniffiTempCreateTxError.NoUtxosSelected = NoUtxosSelected # type: ignore
    class OutputBelowDustLimit(_UniffiTempCreateTxError):

        def __init__(self, index):
            super().__init__(", ".join([
                "index={!r}".format(index),
            ]))
            self.index = index
        def __repr__(self):
            return "CreateTxError.OutputBelowDustLimit({})".format(str(self))
    _UniffiTempCreateTxError.OutputBelowDustLimit = OutputBelowDustLimit # type: ignore
    class ChangePolicyDescriptor(_UniffiTempCreateTxError):

        def __init__(self):
            pass
        def __repr__(self):
            return "CreateTxError.ChangePolicyDescriptor({})".format(str(self))
    _UniffiTempCreateTxError.ChangePolicyDescriptor = ChangePolicyDescriptor # type: ignore
    class CoinSelection(_UniffiTempCreateTxError):

        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message
        def __repr__(self):
            return "CreateTxError.CoinSelection({})".format(str(self))
    _UniffiTempCreateTxError.CoinSelection = CoinSelection # type: ignore
    class InsufficientFunds(_UniffiTempCreateTxError):

        def __init__(self, needed, available):
            super().__init__(", ".join([
                "needed={!r}".format(needed),
                "available={!r}".format(available),
            ]))
            self.needed = needed
            self.available = available
        def __repr__(self):
            return "CreateTxError.InsufficientFunds({})".format(str(self))
    _UniffiTempCreateTxError.InsufficientFunds = InsufficientFunds # type: ignore
    class NoRecipients(_UniffiTempCreateTxError):

        def __init__(self):
            pass
        def __repr__(self):
            return "CreateTxError.NoRecipients({})".format(str(self))
    _UniffiTempCreateTxError.NoRecipients = NoRecipients # type: ignore
    class Psbt(_UniffiTempCreateTxError):

        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message
        def __repr__(self):
            return "CreateTxError.Psbt({})".format(str(self))
    _UniffiTempCreateTxError.Psbt = Psbt # type: ignore
    class MissingKeyOrigin(_UniffiTempCreateTxError):

        def __init__(self, key):
            super().__init__(", ".join([
                "key={!r}".format(key),
            ]))
            self.key = key
        def __repr__(self):
            return "CreateTxError.MissingKeyOrigin({})".format(str(self))
    _UniffiTempCreateTxError.MissingKeyOrigin = MissingKeyOrigin # type: ignore
    class UnknownUtxo(_UniffiTempCreateTxError):

        def __init__(self, outpoint):
            super().__init__(", ".join([
                "outpoint={!r}".format(outpoint),
            ]))
            self.outpoint = outpoint
        def __repr__(self):
            return "CreateTxError.UnknownUtxo({})".format(str(self))
    _UniffiTempCreateTxError.UnknownUtxo = UnknownUtxo # type: ignore
    class MissingNonWitnessUtxo(_UniffiTempCreateTxError):

        def __init__(self, outpoint):
            super().__init__(", ".join([
                "outpoint={!r}".format(outpoint),
            ]))
            self.outpoint = outpoint
        def __repr__(self):
            return "CreateTxError.MissingNonWitnessUtxo({})".format(str(self))
    _UniffiTempCreateTxError.MissingNonWitnessUtxo = MissingNonWitnessUtxo # type: ignore
    class MiniscriptPsbt(_UniffiTempCreateTxError):

        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message
        def __repr__(self):
            return "CreateTxError.MiniscriptPsbt({})".format(str(self))
    _UniffiTempCreateTxError.MiniscriptPsbt = MiniscriptPsbt # type: ignore

CreateTxError = _UniffiTempCreateTxError # type: ignore
del _UniffiTempCreateTxError


class _UniffiConverterTypeCreateTxError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return CreateTxError.Descriptor(
                error_message=_UniffiConverterString.read(buf),
            )
        if variant == 2:
            return CreateTxError.Persist(
                error_message=_UniffiConverterString.read(buf),
            )
        if variant == 3:
            return CreateTxError.Policy(
                error_message=_UniffiConverterString.read(buf),
            )
        if variant == 4:
            return CreateTxError.SpendingPolicyRequired(
                kind=_UniffiConverterString.read(buf),
            )
        if variant == 5:
            return CreateTxError.Version0(
            )
        if variant == 6:
            return CreateTxError.Version1Csv(
            )
        if variant == 7:
            return CreateTxError.LockTime(
                requested=_UniffiConverterString.read(buf),
                required=_UniffiConverterString.read(buf),
            )
        if variant == 8:
            return CreateTxError.RbfSequence(
            )
        if variant == 9:
            return CreateTxError.RbfSequenceCsv(
                rbf=_UniffiConverterString.read(buf),
                csv=_UniffiConverterString.read(buf),
            )
        if variant == 10:
            return CreateTxError.FeeTooLow(
                required=_UniffiConverterUInt64.read(buf),
            )
        if variant == 11:
            return CreateTxError.FeeRateTooLow(
                required=_UniffiConverterString.read(buf),
            )
        if variant == 12:
            return CreateTxError.NoUtxosSelected(
            )
        if variant == 13:
            return CreateTxError.OutputBelowDustLimit(
                index=_UniffiConverterUInt64.read(buf),
            )
        if variant == 14:
            return CreateTxError.ChangePolicyDescriptor(
            )
        if variant == 15:
            return CreateTxError.CoinSelection(
                error_message=_UniffiConverterString.read(buf),
            )
        if variant == 16:
            return CreateTxError.InsufficientFunds(
                needed=_UniffiConverterUInt64.read(buf),
                available=_UniffiConverterUInt64.read(buf),
            )
        if variant == 17:
            return CreateTxError.NoRecipients(
            )
        if variant == 18:
            return CreateTxError.Psbt(
                error_message=_UniffiConverterString.read(buf),
            )
        if variant == 19:
            return CreateTxError.MissingKeyOrigin(
                key=_UniffiConverterString.read(buf),
            )
        if variant == 20:
            return CreateTxError.UnknownUtxo(
                outpoint=_UniffiConverterString.read(buf),
            )
        if variant == 21:
            return CreateTxError.MissingNonWitnessUtxo(
                outpoint=_UniffiConverterString.read(buf),
            )
        if variant == 22:
            return CreateTxError.MiniscriptPsbt(
                error_message=_UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, CreateTxError.Descriptor):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, CreateTxError.Persist):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, CreateTxError.Policy):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, CreateTxError.SpendingPolicyRequired):
            _UniffiConverterString.check_lower(value.kind)
            return
        if isinstance(value, CreateTxError.Version0):
            return
        if isinstance(value, CreateTxError.Version1Csv):
            return
        if isinstance(value, CreateTxError.LockTime):
            _UniffiConverterString.check_lower(value.requested)
            _UniffiConverterString.check_lower(value.required)
            return
        if isinstance(value, CreateTxError.RbfSequence):
            return
        if isinstance(value, CreateTxError.RbfSequenceCsv):
            _UniffiConverterString.check_lower(value.rbf)
            _UniffiConverterString.check_lower(value.csv)
            return
        if isinstance(value, CreateTxError.FeeTooLow):
            _UniffiConverterUInt64.check_lower(value.required)
            return
        if isinstance(value, CreateTxError.FeeRateTooLow):
            _UniffiConverterString.check_lower(value.required)
            return
        if isinstance(value, CreateTxError.NoUtxosSelected):
            return
        if isinstance(value, CreateTxError.OutputBelowDustLimit):
            _UniffiConverterUInt64.check_lower(value.index)
            return
        if isinstance(value, CreateTxError.ChangePolicyDescriptor):
            return
        if isinstance(value, CreateTxError.CoinSelection):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, CreateTxError.InsufficientFunds):
            _UniffiConverterUInt64.check_lower(value.needed)
            _UniffiConverterUInt64.check_lower(value.available)
            return
        if isinstance(value, CreateTxError.NoRecipients):
            return
        if isinstance(value, CreateTxError.Psbt):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, CreateTxError.MissingKeyOrigin):
            _UniffiConverterString.check_lower(value.key)
            return
        if isinstance(value, CreateTxError.UnknownUtxo):
            _UniffiConverterString.check_lower(value.outpoint)
            return
        if isinstance(value, CreateTxError.MissingNonWitnessUtxo):
            _UniffiConverterString.check_lower(value.outpoint)
            return
        if isinstance(value, CreateTxError.MiniscriptPsbt):
            _UniffiConverterString.check_lower(value.error_message)
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, CreateTxError.Descriptor):
            buf.write_i32(1)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, CreateTxError.Persist):
            buf.write_i32(2)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, CreateTxError.Policy):
            buf.write_i32(3)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, CreateTxError.SpendingPolicyRequired):
            buf.write_i32(4)
            _UniffiConverterString.write(value.kind, buf)
        if isinstance(value, CreateTxError.Version0):
            buf.write_i32(5)
        if isinstance(value, CreateTxError.Version1Csv):
            buf.write_i32(6)
        if isinstance(value, CreateTxError.LockTime):
            buf.write_i32(7)
            _UniffiConverterString.write(value.requested, buf)
            _UniffiConverterString.write(value.required, buf)
        if isinstance(value, CreateTxError.RbfSequence):
            buf.write_i32(8)
        if isinstance(value, CreateTxError.RbfSequenceCsv):
            buf.write_i32(9)
            _UniffiConverterString.write(value.rbf, buf)
            _UniffiConverterString.write(value.csv, buf)
        if isinstance(value, CreateTxError.FeeTooLow):
            buf.write_i32(10)
            _UniffiConverterUInt64.write(value.required, buf)
        if isinstance(value, CreateTxError.FeeRateTooLow):
            buf.write_i32(11)
            _UniffiConverterString.write(value.required, buf)
        if isinstance(value, CreateTxError.NoUtxosSelected):
            buf.write_i32(12)
        if isinstance(value, CreateTxError.OutputBelowDustLimit):
            buf.write_i32(13)
            _UniffiConverterUInt64.write(value.index, buf)
        if isinstance(value, CreateTxError.ChangePolicyDescriptor):
            buf.write_i32(14)
        if isinstance(value, CreateTxError.CoinSelection):
            buf.write_i32(15)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, CreateTxError.InsufficientFunds):
            buf.write_i32(16)
            _UniffiConverterUInt64.write(value.needed, buf)
            _UniffiConverterUInt64.write(value.available, buf)
        if isinstance(value, CreateTxError.NoRecipients):
            buf.write_i32(17)
        if isinstance(value, CreateTxError.Psbt):
            buf.write_i32(18)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, CreateTxError.MissingKeyOrigin):
            buf.write_i32(19)
            _UniffiConverterString.write(value.key, buf)
        if isinstance(value, CreateTxError.UnknownUtxo):
            buf.write_i32(20)
            _UniffiConverterString.write(value.outpoint, buf)
        if isinstance(value, CreateTxError.MissingNonWitnessUtxo):
            buf.write_i32(21)
            _UniffiConverterString.write(value.outpoint, buf)
        if isinstance(value, CreateTxError.MiniscriptPsbt):
            buf.write_i32(22)
            _UniffiConverterString.write(value.error_message, buf)


# DescriptorError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class DescriptorError(Exception):
    pass

_UniffiTempDescriptorError = DescriptorError

class DescriptorError:  # type: ignore
    class InvalidHdKeyPath(_UniffiTempDescriptorError):

        def __init__(self):
            pass
        def __repr__(self):
            return "DescriptorError.InvalidHdKeyPath({})".format(str(self))
    _UniffiTempDescriptorError.InvalidHdKeyPath = InvalidHdKeyPath # type: ignore
    class InvalidDescriptorChecksum(_UniffiTempDescriptorError):

        def __init__(self):
            pass
        def __repr__(self):
            return "DescriptorError.InvalidDescriptorChecksum({})".format(str(self))
    _UniffiTempDescriptorError.InvalidDescriptorChecksum = InvalidDescriptorChecksum # type: ignore
    class HardenedDerivationXpub(_UniffiTempDescriptorError):

        def __init__(self):
            pass
        def __repr__(self):
            return "DescriptorError.HardenedDerivationXpub({})".format(str(self))
    _UniffiTempDescriptorError.HardenedDerivationXpub = HardenedDerivationXpub # type: ignore
    class MultiPath(_UniffiTempDescriptorError):

        def __init__(self):
            pass
        def __repr__(self):
            return "DescriptorError.MultiPath({})".format(str(self))
    _UniffiTempDescriptorError.MultiPath = MultiPath # type: ignore
    class Key(_UniffiTempDescriptorError):

        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message
        def __repr__(self):
            return "DescriptorError.Key({})".format(str(self))
    _UniffiTempDescriptorError.Key = Key # type: ignore
    class Policy(_UniffiTempDescriptorError):

        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message
        def __repr__(self):
            return "DescriptorError.Policy({})".format(str(self))
    _UniffiTempDescriptorError.Policy = Policy # type: ignore
    class InvalidDescriptorCharacter(_UniffiTempDescriptorError):

        def __init__(self, char):
            super().__init__(", ".join([
                "char={!r}".format(char),
            ]))
            self.char = char
        def __repr__(self):
            return "DescriptorError.InvalidDescriptorCharacter({})".format(str(self))
    _UniffiTempDescriptorError.InvalidDescriptorCharacter = InvalidDescriptorCharacter # type: ignore
    class Bip32(_UniffiTempDescriptorError):

        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message
        def __repr__(self):
            return "DescriptorError.Bip32({})".format(str(self))
    _UniffiTempDescriptorError.Bip32 = Bip32 # type: ignore
    class Base58(_UniffiTempDescriptorError):

        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message
        def __repr__(self):
            return "DescriptorError.Base58({})".format(str(self))
    _UniffiTempDescriptorError.Base58 = Base58 # type: ignore
    class Pk(_UniffiTempDescriptorError):

        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message
        def __repr__(self):
            return "DescriptorError.Pk({})".format(str(self))
    _UniffiTempDescriptorError.Pk = Pk # type: ignore
    class Miniscript(_UniffiTempDescriptorError):

        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message
        def __repr__(self):
            return "DescriptorError.Miniscript({})".format(str(self))
    _UniffiTempDescriptorError.Miniscript = Miniscript # type: ignore
    class Hex(_UniffiTempDescriptorError):

        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message
        def __repr__(self):
            return "DescriptorError.Hex({})".format(str(self))
    _UniffiTempDescriptorError.Hex = Hex # type: ignore

DescriptorError = _UniffiTempDescriptorError # type: ignore
del _UniffiTempDescriptorError


class _UniffiConverterTypeDescriptorError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return DescriptorError.InvalidHdKeyPath(
            )
        if variant == 2:
            return DescriptorError.InvalidDescriptorChecksum(
            )
        if variant == 3:
            return DescriptorError.HardenedDerivationXpub(
            )
        if variant == 4:
            return DescriptorError.MultiPath(
            )
        if variant == 5:
            return DescriptorError.Key(
                error_message=_UniffiConverterString.read(buf),
            )
        if variant == 6:
            return DescriptorError.Policy(
                error_message=_UniffiConverterString.read(buf),
            )
        if variant == 7:
            return DescriptorError.InvalidDescriptorCharacter(
                char=_UniffiConverterString.read(buf),
            )
        if variant == 8:
            return DescriptorError.Bip32(
                error_message=_UniffiConverterString.read(buf),
            )
        if variant == 9:
            return DescriptorError.Base58(
                error_message=_UniffiConverterString.read(buf),
            )
        if variant == 10:
            return DescriptorError.Pk(
                error_message=_UniffiConverterString.read(buf),
            )
        if variant == 11:
            return DescriptorError.Miniscript(
                error_message=_UniffiConverterString.read(buf),
            )
        if variant == 12:
            return DescriptorError.Hex(
                error_message=_UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, DescriptorError.InvalidHdKeyPath):
            return
        if isinstance(value, DescriptorError.InvalidDescriptorChecksum):
            return
        if isinstance(value, DescriptorError.HardenedDerivationXpub):
            return
        if isinstance(value, DescriptorError.MultiPath):
            return
        if isinstance(value, DescriptorError.Key):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, DescriptorError.Policy):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, DescriptorError.InvalidDescriptorCharacter):
            _UniffiConverterString.check_lower(value.char)
            return
        if isinstance(value, DescriptorError.Bip32):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, DescriptorError.Base58):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, DescriptorError.Pk):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, DescriptorError.Miniscript):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, DescriptorError.Hex):
            _UniffiConverterString.check_lower(value.error_message)
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, DescriptorError.InvalidHdKeyPath):
            buf.write_i32(1)
        if isinstance(value, DescriptorError.InvalidDescriptorChecksum):
            buf.write_i32(2)
        if isinstance(value, DescriptorError.HardenedDerivationXpub):
            buf.write_i32(3)
        if isinstance(value, DescriptorError.MultiPath):
            buf.write_i32(4)
        if isinstance(value, DescriptorError.Key):
            buf.write_i32(5)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, DescriptorError.Policy):
            buf.write_i32(6)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, DescriptorError.InvalidDescriptorCharacter):
            buf.write_i32(7)
            _UniffiConverterString.write(value.char, buf)
        if isinstance(value, DescriptorError.Bip32):
            buf.write_i32(8)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, DescriptorError.Base58):
            buf.write_i32(9)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, DescriptorError.Pk):
            buf.write_i32(10)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, DescriptorError.Miniscript):
            buf.write_i32(11)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, DescriptorError.Hex):
            buf.write_i32(12)
            _UniffiConverterString.write(value.error_message, buf)


# DescriptorKeyError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class DescriptorKeyError(Exception):
    pass

_UniffiTempDescriptorKeyError = DescriptorKeyError

class DescriptorKeyError:  # type: ignore
    class Parse(_UniffiTempDescriptorKeyError):

        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message
        def __repr__(self):
            return "DescriptorKeyError.Parse({})".format(str(self))
    _UniffiTempDescriptorKeyError.Parse = Parse # type: ignore
    class InvalidKeyType(_UniffiTempDescriptorKeyError):

        def __init__(self):
            pass
        def __repr__(self):
            return "DescriptorKeyError.InvalidKeyType({})".format(str(self))
    _UniffiTempDescriptorKeyError.InvalidKeyType = InvalidKeyType # type: ignore
    class Bip32(_UniffiTempDescriptorKeyError):

        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message
        def __repr__(self):
            return "DescriptorKeyError.Bip32({})".format(str(self))
    _UniffiTempDescriptorKeyError.Bip32 = Bip32 # type: ignore

DescriptorKeyError = _UniffiTempDescriptorKeyError # type: ignore
del _UniffiTempDescriptorKeyError


class _UniffiConverterTypeDescriptorKeyError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return DescriptorKeyError.Parse(
                error_message=_UniffiConverterString.read(buf),
            )
        if variant == 2:
            return DescriptorKeyError.InvalidKeyType(
            )
        if variant == 3:
            return DescriptorKeyError.Bip32(
                error_message=_UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, DescriptorKeyError.Parse):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, DescriptorKeyError.InvalidKeyType):
            return
        if isinstance(value, DescriptorKeyError.Bip32):
            _UniffiConverterString.check_lower(value.error_message)
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, DescriptorKeyError.Parse):
            buf.write_i32(1)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, DescriptorKeyError.InvalidKeyType):
            buf.write_i32(2)
        if isinstance(value, DescriptorKeyError.Bip32):
            buf.write_i32(3)
            _UniffiConverterString.write(value.error_message, buf)


# ElectrumError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class ElectrumError(Exception):
    pass

_UniffiTempElectrumError = ElectrumError

class ElectrumError:  # type: ignore
    class IoError(_UniffiTempElectrumError):

        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message
        def __repr__(self):
            return "ElectrumError.IoError({})".format(str(self))
    _UniffiTempElectrumError.IoError = IoError # type: ignore
    class Json(_UniffiTempElectrumError):

        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message
        def __repr__(self):
            return "ElectrumError.Json({})".format(str(self))
    _UniffiTempElectrumError.Json = Json # type: ignore
    class Hex(_UniffiTempElectrumError):

        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message
        def __repr__(self):
            return "ElectrumError.Hex({})".format(str(self))
    _UniffiTempElectrumError.Hex = Hex # type: ignore
    class Protocol(_UniffiTempElectrumError):

        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message
        def __repr__(self):
            return "ElectrumError.Protocol({})".format(str(self))
    _UniffiTempElectrumError.Protocol = Protocol # type: ignore
    class Bitcoin(_UniffiTempElectrumError):

        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message
        def __repr__(self):
            return "ElectrumError.Bitcoin({})".format(str(self))
    _UniffiTempElectrumError.Bitcoin = Bitcoin # type: ignore
    class AlreadySubscribed(_UniffiTempElectrumError):

        def __init__(self):
            pass
        def __repr__(self):
            return "ElectrumError.AlreadySubscribed({})".format(str(self))
    _UniffiTempElectrumError.AlreadySubscribed = AlreadySubscribed # type: ignore
    class NotSubscribed(_UniffiTempElectrumError):

        def __init__(self):
            pass
        def __repr__(self):
            return "ElectrumError.NotSubscribed({})".format(str(self))
    _UniffiTempElectrumError.NotSubscribed = NotSubscribed # type: ignore
    class InvalidResponse(_UniffiTempElectrumError):

        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message
        def __repr__(self):
            return "ElectrumError.InvalidResponse({})".format(str(self))
    _UniffiTempElectrumError.InvalidResponse = InvalidResponse # type: ignore
    class Message(_UniffiTempElectrumError):

        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message
        def __repr__(self):
            return "ElectrumError.Message({})".format(str(self))
    _UniffiTempElectrumError.Message = Message # type: ignore
    class InvalidDnsNameError(_UniffiTempElectrumError):

        def __init__(self, domain):
            super().__init__(", ".join([
                "domain={!r}".format(domain),
            ]))
            self.domain = domain
        def __repr__(self):
            return "ElectrumError.InvalidDnsNameError({})".format(str(self))
    _UniffiTempElectrumError.InvalidDnsNameError = InvalidDnsNameError # type: ignore
    class MissingDomain(_UniffiTempElectrumError):

        def __init__(self):
            pass
        def __repr__(self):
            return "ElectrumError.MissingDomain({})".format(str(self))
    _UniffiTempElectrumError.MissingDomain = MissingDomain # type: ignore
    class AllAttemptsErrored(_UniffiTempElectrumError):

        def __init__(self):
            pass
        def __repr__(self):
            return "ElectrumError.AllAttemptsErrored({})".format(str(self))
    _UniffiTempElectrumError.AllAttemptsErrored = AllAttemptsErrored # type: ignore
    class SharedIoError(_UniffiTempElectrumError):

        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message
        def __repr__(self):
            return "ElectrumError.SharedIoError({})".format(str(self))
    _UniffiTempElectrumError.SharedIoError = SharedIoError # type: ignore
    class CouldntLockReader(_UniffiTempElectrumError):

        def __init__(self):
            pass
        def __repr__(self):
            return "ElectrumError.CouldntLockReader({})".format(str(self))
    _UniffiTempElectrumError.CouldntLockReader = CouldntLockReader # type: ignore
    class Mpsc(_UniffiTempElectrumError):

        def __init__(self):
            pass
        def __repr__(self):
            return "ElectrumError.Mpsc({})".format(str(self))
    _UniffiTempElectrumError.Mpsc = Mpsc # type: ignore
    class CouldNotCreateConnection(_UniffiTempElectrumError):

        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message
        def __repr__(self):
            return "ElectrumError.CouldNotCreateConnection({})".format(str(self))
    _UniffiTempElectrumError.CouldNotCreateConnection = CouldNotCreateConnection # type: ignore
    class RequestAlreadyConsumed(_UniffiTempElectrumError):

        def __init__(self):
            pass
        def __repr__(self):
            return "ElectrumError.RequestAlreadyConsumed({})".format(str(self))
    _UniffiTempElectrumError.RequestAlreadyConsumed = RequestAlreadyConsumed # type: ignore

ElectrumError = _UniffiTempElectrumError # type: ignore
del _UniffiTempElectrumError


class _UniffiConverterTypeElectrumError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ElectrumError.IoError(
                error_message=_UniffiConverterString.read(buf),
            )
        if variant == 2:
            return ElectrumError.Json(
                error_message=_UniffiConverterString.read(buf),
            )
        if variant == 3:
            return ElectrumError.Hex(
                error_message=_UniffiConverterString.read(buf),
            )
        if variant == 4:
            return ElectrumError.Protocol(
                error_message=_UniffiConverterString.read(buf),
            )
        if variant == 5:
            return ElectrumError.Bitcoin(
                error_message=_UniffiConverterString.read(buf),
            )
        if variant == 6:
            return ElectrumError.AlreadySubscribed(
            )
        if variant == 7:
            return ElectrumError.NotSubscribed(
            )
        if variant == 8:
            return ElectrumError.InvalidResponse(
                error_message=_UniffiConverterString.read(buf),
            )
        if variant == 9:
            return ElectrumError.Message(
                error_message=_UniffiConverterString.read(buf),
            )
        if variant == 10:
            return ElectrumError.InvalidDnsNameError(
                domain=_UniffiConverterString.read(buf),
            )
        if variant == 11:
            return ElectrumError.MissingDomain(
            )
        if variant == 12:
            return ElectrumError.AllAttemptsErrored(
            )
        if variant == 13:
            return ElectrumError.SharedIoError(
                error_message=_UniffiConverterString.read(buf),
            )
        if variant == 14:
            return ElectrumError.CouldntLockReader(
            )
        if variant == 15:
            return ElectrumError.Mpsc(
            )
        if variant == 16:
            return ElectrumError.CouldNotCreateConnection(
                error_message=_UniffiConverterString.read(buf),
            )
        if variant == 17:
            return ElectrumError.RequestAlreadyConsumed(
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, ElectrumError.IoError):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, ElectrumError.Json):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, ElectrumError.Hex):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, ElectrumError.Protocol):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, ElectrumError.Bitcoin):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, ElectrumError.AlreadySubscribed):
            return
        if isinstance(value, ElectrumError.NotSubscribed):
            return
        if isinstance(value, ElectrumError.InvalidResponse):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, ElectrumError.Message):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, ElectrumError.InvalidDnsNameError):
            _UniffiConverterString.check_lower(value.domain)
            return
        if isinstance(value, ElectrumError.MissingDomain):
            return
        if isinstance(value, ElectrumError.AllAttemptsErrored):
            return
        if isinstance(value, ElectrumError.SharedIoError):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, ElectrumError.CouldntLockReader):
            return
        if isinstance(value, ElectrumError.Mpsc):
            return
        if isinstance(value, ElectrumError.CouldNotCreateConnection):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, ElectrumError.RequestAlreadyConsumed):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, ElectrumError.IoError):
            buf.write_i32(1)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, ElectrumError.Json):
            buf.write_i32(2)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, ElectrumError.Hex):
            buf.write_i32(3)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, ElectrumError.Protocol):
            buf.write_i32(4)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, ElectrumError.Bitcoin):
            buf.write_i32(5)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, ElectrumError.AlreadySubscribed):
            buf.write_i32(6)
        if isinstance(value, ElectrumError.NotSubscribed):
            buf.write_i32(7)
        if isinstance(value, ElectrumError.InvalidResponse):
            buf.write_i32(8)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, ElectrumError.Message):
            buf.write_i32(9)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, ElectrumError.InvalidDnsNameError):
            buf.write_i32(10)
            _UniffiConverterString.write(value.domain, buf)
        if isinstance(value, ElectrumError.MissingDomain):
            buf.write_i32(11)
        if isinstance(value, ElectrumError.AllAttemptsErrored):
            buf.write_i32(12)
        if isinstance(value, ElectrumError.SharedIoError):
            buf.write_i32(13)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, ElectrumError.CouldntLockReader):
            buf.write_i32(14)
        if isinstance(value, ElectrumError.Mpsc):
            buf.write_i32(15)
        if isinstance(value, ElectrumError.CouldNotCreateConnection):
            buf.write_i32(16)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, ElectrumError.RequestAlreadyConsumed):
            buf.write_i32(17)


# EsploraError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class EsploraError(Exception):
    pass

_UniffiTempEsploraError = EsploraError

class EsploraError:  # type: ignore
    class Minreq(_UniffiTempEsploraError):

        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message
        def __repr__(self):
            return "EsploraError.Minreq({})".format(str(self))
    _UniffiTempEsploraError.Minreq = Minreq # type: ignore
    class HttpResponse(_UniffiTempEsploraError):

        def __init__(self, status, error_message):
            super().__init__(", ".join([
                "status={!r}".format(status),
                "error_message={!r}".format(error_message),
            ]))
            self.status = status
            self.error_message = error_message
        def __repr__(self):
            return "EsploraError.HttpResponse({})".format(str(self))
    _UniffiTempEsploraError.HttpResponse = HttpResponse # type: ignore
    class Parsing(_UniffiTempEsploraError):

        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message
        def __repr__(self):
            return "EsploraError.Parsing({})".format(str(self))
    _UniffiTempEsploraError.Parsing = Parsing # type: ignore
    class StatusCode(_UniffiTempEsploraError):

        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message
        def __repr__(self):
            return "EsploraError.StatusCode({})".format(str(self))
    _UniffiTempEsploraError.StatusCode = StatusCode # type: ignore
    class BitcoinEncoding(_UniffiTempEsploraError):

        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message
        def __repr__(self):
            return "EsploraError.BitcoinEncoding({})".format(str(self))
    _UniffiTempEsploraError.BitcoinEncoding = BitcoinEncoding # type: ignore
    class HexToArray(_UniffiTempEsploraError):

        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message
        def __repr__(self):
            return "EsploraError.HexToArray({})".format(str(self))
    _UniffiTempEsploraError.HexToArray = HexToArray # type: ignore
    class HexToBytes(_UniffiTempEsploraError):

        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message
        def __repr__(self):
            return "EsploraError.HexToBytes({})".format(str(self))
    _UniffiTempEsploraError.HexToBytes = HexToBytes # type: ignore
    class TransactionNotFound(_UniffiTempEsploraError):

        def __init__(self):
            pass
        def __repr__(self):
            return "EsploraError.TransactionNotFound({})".format(str(self))
    _UniffiTempEsploraError.TransactionNotFound = TransactionNotFound # type: ignore
    class HeaderHeightNotFound(_UniffiTempEsploraError):

        def __init__(self, height):
            super().__init__(", ".join([
                "height={!r}".format(height),
            ]))
            self.height = height
        def __repr__(self):
            return "EsploraError.HeaderHeightNotFound({})".format(str(self))
    _UniffiTempEsploraError.HeaderHeightNotFound = HeaderHeightNotFound # type: ignore
    class HeaderHashNotFound(_UniffiTempEsploraError):

        def __init__(self):
            pass
        def __repr__(self):
            return "EsploraError.HeaderHashNotFound({})".format(str(self))
    _UniffiTempEsploraError.HeaderHashNotFound = HeaderHashNotFound # type: ignore
    class InvalidHttpHeaderName(_UniffiTempEsploraError):

        def __init__(self, name):
            super().__init__(", ".join([
                "name={!r}".format(name),
            ]))
            self.name = name
        def __repr__(self):
            return "EsploraError.InvalidHttpHeaderName({})".format(str(self))
    _UniffiTempEsploraError.InvalidHttpHeaderName = InvalidHttpHeaderName # type: ignore
    class InvalidHttpHeaderValue(_UniffiTempEsploraError):

        def __init__(self, value):
            super().__init__(", ".join([
                "value={!r}".format(value),
            ]))
            self.value = value
        def __repr__(self):
            return "EsploraError.InvalidHttpHeaderValue({})".format(str(self))
    _UniffiTempEsploraError.InvalidHttpHeaderValue = InvalidHttpHeaderValue # type: ignore
    class RequestAlreadyConsumed(_UniffiTempEsploraError):

        def __init__(self):
            pass
        def __repr__(self):
            return "EsploraError.RequestAlreadyConsumed({})".format(str(self))
    _UniffiTempEsploraError.RequestAlreadyConsumed = RequestAlreadyConsumed # type: ignore

EsploraError = _UniffiTempEsploraError # type: ignore
del _UniffiTempEsploraError


class _UniffiConverterTypeEsploraError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return EsploraError.Minreq(
                error_message=_UniffiConverterString.read(buf),
            )
        if variant == 2:
            return EsploraError.HttpResponse(
                status=_UniffiConverterUInt16.read(buf),
                error_message=_UniffiConverterString.read(buf),
            )
        if variant == 3:
            return EsploraError.Parsing(
                error_message=_UniffiConverterString.read(buf),
            )
        if variant == 4:
            return EsploraError.StatusCode(
                error_message=_UniffiConverterString.read(buf),
            )
        if variant == 5:
            return EsploraError.BitcoinEncoding(
                error_message=_UniffiConverterString.read(buf),
            )
        if variant == 6:
            return EsploraError.HexToArray(
                error_message=_UniffiConverterString.read(buf),
            )
        if variant == 7:
            return EsploraError.HexToBytes(
                error_message=_UniffiConverterString.read(buf),
            )
        if variant == 8:
            return EsploraError.TransactionNotFound(
            )
        if variant == 9:
            return EsploraError.HeaderHeightNotFound(
                height=_UniffiConverterUInt32.read(buf),
            )
        if variant == 10:
            return EsploraError.HeaderHashNotFound(
            )
        if variant == 11:
            return EsploraError.InvalidHttpHeaderName(
                name=_UniffiConverterString.read(buf),
            )
        if variant == 12:
            return EsploraError.InvalidHttpHeaderValue(
                value=_UniffiConverterString.read(buf),
            )
        if variant == 13:
            return EsploraError.RequestAlreadyConsumed(
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, EsploraError.Minreq):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, EsploraError.HttpResponse):
            _UniffiConverterUInt16.check_lower(value.status)
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, EsploraError.Parsing):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, EsploraError.StatusCode):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, EsploraError.BitcoinEncoding):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, EsploraError.HexToArray):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, EsploraError.HexToBytes):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, EsploraError.TransactionNotFound):
            return
        if isinstance(value, EsploraError.HeaderHeightNotFound):
            _UniffiConverterUInt32.check_lower(value.height)
            return
        if isinstance(value, EsploraError.HeaderHashNotFound):
            return
        if isinstance(value, EsploraError.InvalidHttpHeaderName):
            _UniffiConverterString.check_lower(value.name)
            return
        if isinstance(value, EsploraError.InvalidHttpHeaderValue):
            _UniffiConverterString.check_lower(value.value)
            return
        if isinstance(value, EsploraError.RequestAlreadyConsumed):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, EsploraError.Minreq):
            buf.write_i32(1)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, EsploraError.HttpResponse):
            buf.write_i32(2)
            _UniffiConverterUInt16.write(value.status, buf)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, EsploraError.Parsing):
            buf.write_i32(3)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, EsploraError.StatusCode):
            buf.write_i32(4)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, EsploraError.BitcoinEncoding):
            buf.write_i32(5)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, EsploraError.HexToArray):
            buf.write_i32(6)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, EsploraError.HexToBytes):
            buf.write_i32(7)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, EsploraError.TransactionNotFound):
            buf.write_i32(8)
        if isinstance(value, EsploraError.HeaderHeightNotFound):
            buf.write_i32(9)
            _UniffiConverterUInt32.write(value.height, buf)
        if isinstance(value, EsploraError.HeaderHashNotFound):
            buf.write_i32(10)
        if isinstance(value, EsploraError.InvalidHttpHeaderName):
            buf.write_i32(11)
            _UniffiConverterString.write(value.name, buf)
        if isinstance(value, EsploraError.InvalidHttpHeaderValue):
            buf.write_i32(12)
            _UniffiConverterString.write(value.value, buf)
        if isinstance(value, EsploraError.RequestAlreadyConsumed):
            buf.write_i32(13)


# ExtractTxError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class ExtractTxError(Exception):
    pass

_UniffiTempExtractTxError = ExtractTxError

class ExtractTxError:  # type: ignore
    class AbsurdFeeRate(_UniffiTempExtractTxError):

        def __init__(self, fee_rate):
            super().__init__(", ".join([
                "fee_rate={!r}".format(fee_rate),
            ]))
            self.fee_rate = fee_rate
        def __repr__(self):
            return "ExtractTxError.AbsurdFeeRate({})".format(str(self))
    _UniffiTempExtractTxError.AbsurdFeeRate = AbsurdFeeRate # type: ignore
    class MissingInputValue(_UniffiTempExtractTxError):

        def __init__(self):
            pass
        def __repr__(self):
            return "ExtractTxError.MissingInputValue({})".format(str(self))
    _UniffiTempExtractTxError.MissingInputValue = MissingInputValue # type: ignore
    class SendingTooMuch(_UniffiTempExtractTxError):

        def __init__(self):
            pass
        def __repr__(self):
            return "ExtractTxError.SendingTooMuch({})".format(str(self))
    _UniffiTempExtractTxError.SendingTooMuch = SendingTooMuch # type: ignore
    class OtherExtractTxErr(_UniffiTempExtractTxError):

        def __init__(self):
            pass
        def __repr__(self):
            return "ExtractTxError.OtherExtractTxErr({})".format(str(self))
    _UniffiTempExtractTxError.OtherExtractTxErr = OtherExtractTxErr # type: ignore

ExtractTxError = _UniffiTempExtractTxError # type: ignore
del _UniffiTempExtractTxError


class _UniffiConverterTypeExtractTxError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ExtractTxError.AbsurdFeeRate(
                fee_rate=_UniffiConverterUInt64.read(buf),
            )
        if variant == 2:
            return ExtractTxError.MissingInputValue(
            )
        if variant == 3:
            return ExtractTxError.SendingTooMuch(
            )
        if variant == 4:
            return ExtractTxError.OtherExtractTxErr(
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, ExtractTxError.AbsurdFeeRate):
            _UniffiConverterUInt64.check_lower(value.fee_rate)
            return
        if isinstance(value, ExtractTxError.MissingInputValue):
            return
        if isinstance(value, ExtractTxError.SendingTooMuch):
            return
        if isinstance(value, ExtractTxError.OtherExtractTxErr):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, ExtractTxError.AbsurdFeeRate):
            buf.write_i32(1)
            _UniffiConverterUInt64.write(value.fee_rate, buf)
        if isinstance(value, ExtractTxError.MissingInputValue):
            buf.write_i32(2)
        if isinstance(value, ExtractTxError.SendingTooMuch):
            buf.write_i32(3)
        if isinstance(value, ExtractTxError.OtherExtractTxErr):
            buf.write_i32(4)


# FeeRateError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class FeeRateError(Exception):
    pass

_UniffiTempFeeRateError = FeeRateError

class FeeRateError:  # type: ignore
    class ArithmeticOverflow(_UniffiTempFeeRateError):

        def __repr__(self):
            return "FeeRateError.ArithmeticOverflow({})".format(repr(str(self)))
    _UniffiTempFeeRateError.ArithmeticOverflow = ArithmeticOverflow # type: ignore

FeeRateError = _UniffiTempFeeRateError # type: ignore
del _UniffiTempFeeRateError


class _UniffiConverterTypeFeeRateError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FeeRateError.ArithmeticOverflow(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, FeeRateError.ArithmeticOverflow):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, FeeRateError.ArithmeticOverflow):
            buf.write_i32(1)





class KeychainKind(enum.Enum):
    EXTERNAL = 0
    
    INTERNAL = 1
    


class _UniffiConverterTypeKeychainKind(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return KeychainKind.EXTERNAL
        if variant == 2:
            return KeychainKind.INTERNAL
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == KeychainKind.EXTERNAL:
            return
        if value == KeychainKind.INTERNAL:
            return

    @staticmethod
    def write(value, buf):
        if value == KeychainKind.EXTERNAL:
            buf.write_i32(1)
        if value == KeychainKind.INTERNAL:
            buf.write_i32(2)







class Network(enum.Enum):
    BITCOIN = 0
    
    TESTNET = 1
    
    SIGNET = 2
    
    REGTEST = 3
    


class _UniffiConverterTypeNetwork(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Network.BITCOIN
        if variant == 2:
            return Network.TESTNET
        if variant == 3:
            return Network.SIGNET
        if variant == 4:
            return Network.REGTEST
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == Network.BITCOIN:
            return
        if value == Network.TESTNET:
            return
        if value == Network.SIGNET:
            return
        if value == Network.REGTEST:
            return

    @staticmethod
    def write(value, buf):
        if value == Network.BITCOIN:
            buf.write_i32(1)
        if value == Network.TESTNET:
            buf.write_i32(2)
        if value == Network.SIGNET:
            buf.write_i32(3)
        if value == Network.REGTEST:
            buf.write_i32(4)




# ParseAmountError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class ParseAmountError(Exception):
    pass

_UniffiTempParseAmountError = ParseAmountError

class ParseAmountError:  # type: ignore
    class Negative(_UniffiTempParseAmountError):

        def __init__(self):
            pass
        def __repr__(self):
            return "ParseAmountError.Negative({})".format(str(self))
    _UniffiTempParseAmountError.Negative = Negative # type: ignore
    class TooBig(_UniffiTempParseAmountError):

        def __init__(self):
            pass
        def __repr__(self):
            return "ParseAmountError.TooBig({})".format(str(self))
    _UniffiTempParseAmountError.TooBig = TooBig # type: ignore
    class TooPrecise(_UniffiTempParseAmountError):

        def __init__(self):
            pass
        def __repr__(self):
            return "ParseAmountError.TooPrecise({})".format(str(self))
    _UniffiTempParseAmountError.TooPrecise = TooPrecise # type: ignore
    class InvalidFormat(_UniffiTempParseAmountError):

        def __init__(self):
            pass
        def __repr__(self):
            return "ParseAmountError.InvalidFormat({})".format(str(self))
    _UniffiTempParseAmountError.InvalidFormat = InvalidFormat # type: ignore
    class InputTooLarge(_UniffiTempParseAmountError):

        def __init__(self):
            pass
        def __repr__(self):
            return "ParseAmountError.InputTooLarge({})".format(str(self))
    _UniffiTempParseAmountError.InputTooLarge = InputTooLarge # type: ignore
    class InvalidCharacter(_UniffiTempParseAmountError):

        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message
        def __repr__(self):
            return "ParseAmountError.InvalidCharacter({})".format(str(self))
    _UniffiTempParseAmountError.InvalidCharacter = InvalidCharacter # type: ignore
    class UnknownDenomination(_UniffiTempParseAmountError):

        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message
        def __repr__(self):
            return "ParseAmountError.UnknownDenomination({})".format(str(self))
    _UniffiTempParseAmountError.UnknownDenomination = UnknownDenomination # type: ignore
    class PossiblyConfusingDenomination(_UniffiTempParseAmountError):

        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message
        def __repr__(self):
            return "ParseAmountError.PossiblyConfusingDenomination({})".format(str(self))
    _UniffiTempParseAmountError.PossiblyConfusingDenomination = PossiblyConfusingDenomination # type: ignore
    class OtherParseAmountErr(_UniffiTempParseAmountError):

        def __init__(self):
            pass
        def __repr__(self):
            return "ParseAmountError.OtherParseAmountErr({})".format(str(self))
    _UniffiTempParseAmountError.OtherParseAmountErr = OtherParseAmountErr # type: ignore

ParseAmountError = _UniffiTempParseAmountError # type: ignore
del _UniffiTempParseAmountError


class _UniffiConverterTypeParseAmountError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ParseAmountError.Negative(
            )
        if variant == 2:
            return ParseAmountError.TooBig(
            )
        if variant == 3:
            return ParseAmountError.TooPrecise(
            )
        if variant == 4:
            return ParseAmountError.InvalidFormat(
            )
        if variant == 5:
            return ParseAmountError.InputTooLarge(
            )
        if variant == 6:
            return ParseAmountError.InvalidCharacter(
                error_message=_UniffiConverterString.read(buf),
            )
        if variant == 7:
            return ParseAmountError.UnknownDenomination(
                error_message=_UniffiConverterString.read(buf),
            )
        if variant == 8:
            return ParseAmountError.PossiblyConfusingDenomination(
                error_message=_UniffiConverterString.read(buf),
            )
        if variant == 9:
            return ParseAmountError.OtherParseAmountErr(
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, ParseAmountError.Negative):
            return
        if isinstance(value, ParseAmountError.TooBig):
            return
        if isinstance(value, ParseAmountError.TooPrecise):
            return
        if isinstance(value, ParseAmountError.InvalidFormat):
            return
        if isinstance(value, ParseAmountError.InputTooLarge):
            return
        if isinstance(value, ParseAmountError.InvalidCharacter):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, ParseAmountError.UnknownDenomination):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, ParseAmountError.PossiblyConfusingDenomination):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, ParseAmountError.OtherParseAmountErr):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, ParseAmountError.Negative):
            buf.write_i32(1)
        if isinstance(value, ParseAmountError.TooBig):
            buf.write_i32(2)
        if isinstance(value, ParseAmountError.TooPrecise):
            buf.write_i32(3)
        if isinstance(value, ParseAmountError.InvalidFormat):
            buf.write_i32(4)
        if isinstance(value, ParseAmountError.InputTooLarge):
            buf.write_i32(5)
        if isinstance(value, ParseAmountError.InvalidCharacter):
            buf.write_i32(6)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, ParseAmountError.UnknownDenomination):
            buf.write_i32(7)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, ParseAmountError.PossiblyConfusingDenomination):
            buf.write_i32(8)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, ParseAmountError.OtherParseAmountErr):
            buf.write_i32(9)


# PersistenceError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class PersistenceError(Exception):
    pass

_UniffiTempPersistenceError = PersistenceError

class PersistenceError:  # type: ignore
    class Write(_UniffiTempPersistenceError):

        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message
        def __repr__(self):
            return "PersistenceError.Write({})".format(str(self))
    _UniffiTempPersistenceError.Write = Write # type: ignore

PersistenceError = _UniffiTempPersistenceError # type: ignore
del _UniffiTempPersistenceError


class _UniffiConverterTypePersistenceError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return PersistenceError.Write(
                error_message=_UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, PersistenceError.Write):
            _UniffiConverterString.check_lower(value.error_message)
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, PersistenceError.Write):
            buf.write_i32(1)
            _UniffiConverterString.write(value.error_message, buf)


# PsbtParseError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class PsbtParseError(Exception):
    pass

_UniffiTempPsbtParseError = PsbtParseError

class PsbtParseError:  # type: ignore
    class PsbtEncoding(_UniffiTempPsbtParseError):

        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message
        def __repr__(self):
            return "PsbtParseError.PsbtEncoding({})".format(str(self))
    _UniffiTempPsbtParseError.PsbtEncoding = PsbtEncoding # type: ignore
    class Base64Encoding(_UniffiTempPsbtParseError):

        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message
        def __repr__(self):
            return "PsbtParseError.Base64Encoding({})".format(str(self))
    _UniffiTempPsbtParseError.Base64Encoding = Base64Encoding # type: ignore

PsbtParseError = _UniffiTempPsbtParseError # type: ignore
del _UniffiTempPsbtParseError


class _UniffiConverterTypePsbtParseError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return PsbtParseError.PsbtEncoding(
                error_message=_UniffiConverterString.read(buf),
            )
        if variant == 2:
            return PsbtParseError.Base64Encoding(
                error_message=_UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, PsbtParseError.PsbtEncoding):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, PsbtParseError.Base64Encoding):
            _UniffiConverterString.check_lower(value.error_message)
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, PsbtParseError.PsbtEncoding):
            buf.write_i32(1)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, PsbtParseError.Base64Encoding):
            buf.write_i32(2)
            _UniffiConverterString.write(value.error_message, buf)


# SignerError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class SignerError(Exception):
    pass

_UniffiTempSignerError = SignerError

class SignerError:  # type: ignore
    class MissingKey(_UniffiTempSignerError):

        def __init__(self):
            pass
        def __repr__(self):
            return "SignerError.MissingKey({})".format(str(self))
    _UniffiTempSignerError.MissingKey = MissingKey # type: ignore
    class InvalidKey(_UniffiTempSignerError):

        def __init__(self):
            pass
        def __repr__(self):
            return "SignerError.InvalidKey({})".format(str(self))
    _UniffiTempSignerError.InvalidKey = InvalidKey # type: ignore
    class UserCanceled(_UniffiTempSignerError):

        def __init__(self):
            pass
        def __repr__(self):
            return "SignerError.UserCanceled({})".format(str(self))
    _UniffiTempSignerError.UserCanceled = UserCanceled # type: ignore
    class InputIndexOutOfRange(_UniffiTempSignerError):

        def __init__(self):
            pass
        def __repr__(self):
            return "SignerError.InputIndexOutOfRange({})".format(str(self))
    _UniffiTempSignerError.InputIndexOutOfRange = InputIndexOutOfRange # type: ignore
    class MissingNonWitnessUtxo(_UniffiTempSignerError):

        def __init__(self):
            pass
        def __repr__(self):
            return "SignerError.MissingNonWitnessUtxo({})".format(str(self))
    _UniffiTempSignerError.MissingNonWitnessUtxo = MissingNonWitnessUtxo # type: ignore
    class InvalidNonWitnessUtxo(_UniffiTempSignerError):

        def __init__(self):
            pass
        def __repr__(self):
            return "SignerError.InvalidNonWitnessUtxo({})".format(str(self))
    _UniffiTempSignerError.InvalidNonWitnessUtxo = InvalidNonWitnessUtxo # type: ignore
    class MissingWitnessUtxo(_UniffiTempSignerError):

        def __init__(self):
            pass
        def __repr__(self):
            return "SignerError.MissingWitnessUtxo({})".format(str(self))
    _UniffiTempSignerError.MissingWitnessUtxo = MissingWitnessUtxo # type: ignore
    class MissingWitnessScript(_UniffiTempSignerError):

        def __init__(self):
            pass
        def __repr__(self):
            return "SignerError.MissingWitnessScript({})".format(str(self))
    _UniffiTempSignerError.MissingWitnessScript = MissingWitnessScript # type: ignore
    class MissingHdKeypath(_UniffiTempSignerError):

        def __init__(self):
            pass
        def __repr__(self):
            return "SignerError.MissingHdKeypath({})".format(str(self))
    _UniffiTempSignerError.MissingHdKeypath = MissingHdKeypath # type: ignore
    class NonStandardSighash(_UniffiTempSignerError):

        def __init__(self):
            pass
        def __repr__(self):
            return "SignerError.NonStandardSighash({})".format(str(self))
    _UniffiTempSignerError.NonStandardSighash = NonStandardSighash # type: ignore
    class InvalidSighash(_UniffiTempSignerError):

        def __init__(self):
            pass
        def __repr__(self):
            return "SignerError.InvalidSighash({})".format(str(self))
    _UniffiTempSignerError.InvalidSighash = InvalidSighash # type: ignore
    class SighashError(_UniffiTempSignerError):

        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message
        def __repr__(self):
            return "SignerError.SighashError({})".format(str(self))
    _UniffiTempSignerError.SighashError = SighashError # type: ignore
    class MiniscriptPsbt(_UniffiTempSignerError):

        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message
        def __repr__(self):
            return "SignerError.MiniscriptPsbt({})".format(str(self))
    _UniffiTempSignerError.MiniscriptPsbt = MiniscriptPsbt # type: ignore
    class External(_UniffiTempSignerError):

        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message
        def __repr__(self):
            return "SignerError.External({})".format(str(self))
    _UniffiTempSignerError.External = External # type: ignore

SignerError = _UniffiTempSignerError # type: ignore
del _UniffiTempSignerError


class _UniffiConverterTypeSignerError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return SignerError.MissingKey(
            )
        if variant == 2:
            return SignerError.InvalidKey(
            )
        if variant == 3:
            return SignerError.UserCanceled(
            )
        if variant == 4:
            return SignerError.InputIndexOutOfRange(
            )
        if variant == 5:
            return SignerError.MissingNonWitnessUtxo(
            )
        if variant == 6:
            return SignerError.InvalidNonWitnessUtxo(
            )
        if variant == 7:
            return SignerError.MissingWitnessUtxo(
            )
        if variant == 8:
            return SignerError.MissingWitnessScript(
            )
        if variant == 9:
            return SignerError.MissingHdKeypath(
            )
        if variant == 10:
            return SignerError.NonStandardSighash(
            )
        if variant == 11:
            return SignerError.InvalidSighash(
            )
        if variant == 12:
            return SignerError.SighashError(
                error_message=_UniffiConverterString.read(buf),
            )
        if variant == 13:
            return SignerError.MiniscriptPsbt(
                error_message=_UniffiConverterString.read(buf),
            )
        if variant == 14:
            return SignerError.External(
                error_message=_UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, SignerError.MissingKey):
            return
        if isinstance(value, SignerError.InvalidKey):
            return
        if isinstance(value, SignerError.UserCanceled):
            return
        if isinstance(value, SignerError.InputIndexOutOfRange):
            return
        if isinstance(value, SignerError.MissingNonWitnessUtxo):
            return
        if isinstance(value, SignerError.InvalidNonWitnessUtxo):
            return
        if isinstance(value, SignerError.MissingWitnessUtxo):
            return
        if isinstance(value, SignerError.MissingWitnessScript):
            return
        if isinstance(value, SignerError.MissingHdKeypath):
            return
        if isinstance(value, SignerError.NonStandardSighash):
            return
        if isinstance(value, SignerError.InvalidSighash):
            return
        if isinstance(value, SignerError.SighashError):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, SignerError.MiniscriptPsbt):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, SignerError.External):
            _UniffiConverterString.check_lower(value.error_message)
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, SignerError.MissingKey):
            buf.write_i32(1)
        if isinstance(value, SignerError.InvalidKey):
            buf.write_i32(2)
        if isinstance(value, SignerError.UserCanceled):
            buf.write_i32(3)
        if isinstance(value, SignerError.InputIndexOutOfRange):
            buf.write_i32(4)
        if isinstance(value, SignerError.MissingNonWitnessUtxo):
            buf.write_i32(5)
        if isinstance(value, SignerError.InvalidNonWitnessUtxo):
            buf.write_i32(6)
        if isinstance(value, SignerError.MissingWitnessUtxo):
            buf.write_i32(7)
        if isinstance(value, SignerError.MissingWitnessScript):
            buf.write_i32(8)
        if isinstance(value, SignerError.MissingHdKeypath):
            buf.write_i32(9)
        if isinstance(value, SignerError.NonStandardSighash):
            buf.write_i32(10)
        if isinstance(value, SignerError.InvalidSighash):
            buf.write_i32(11)
        if isinstance(value, SignerError.SighashError):
            buf.write_i32(12)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, SignerError.MiniscriptPsbt):
            buf.write_i32(13)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, SignerError.External):
            buf.write_i32(14)
            _UniffiConverterString.write(value.error_message, buf)


# TransactionError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class TransactionError(Exception):
    pass

_UniffiTempTransactionError = TransactionError

class TransactionError:  # type: ignore
    class Io(_UniffiTempTransactionError):

        def __init__(self):
            pass
        def __repr__(self):
            return "TransactionError.Io({})".format(str(self))
    _UniffiTempTransactionError.Io = Io # type: ignore
    class OversizedVectorAllocation(_UniffiTempTransactionError):

        def __init__(self):
            pass
        def __repr__(self):
            return "TransactionError.OversizedVectorAllocation({})".format(str(self))
    _UniffiTempTransactionError.OversizedVectorAllocation = OversizedVectorAllocation # type: ignore
    class InvalidChecksum(_UniffiTempTransactionError):

        def __init__(self, expected, actual):
            super().__init__(", ".join([
                "expected={!r}".format(expected),
                "actual={!r}".format(actual),
            ]))
            self.expected = expected
            self.actual = actual
        def __repr__(self):
            return "TransactionError.InvalidChecksum({})".format(str(self))
    _UniffiTempTransactionError.InvalidChecksum = InvalidChecksum # type: ignore
    class NonMinimalVarInt(_UniffiTempTransactionError):

        def __init__(self):
            pass
        def __repr__(self):
            return "TransactionError.NonMinimalVarInt({})".format(str(self))
    _UniffiTempTransactionError.NonMinimalVarInt = NonMinimalVarInt # type: ignore
    class ParseFailed(_UniffiTempTransactionError):

        def __init__(self):
            pass
        def __repr__(self):
            return "TransactionError.ParseFailed({})".format(str(self))
    _UniffiTempTransactionError.ParseFailed = ParseFailed # type: ignore
    class UnsupportedSegwitFlag(_UniffiTempTransactionError):

        def __init__(self, flag):
            super().__init__(", ".join([
                "flag={!r}".format(flag),
            ]))
            self.flag = flag
        def __repr__(self):
            return "TransactionError.UnsupportedSegwitFlag({})".format(str(self))
    _UniffiTempTransactionError.UnsupportedSegwitFlag = UnsupportedSegwitFlag # type: ignore
    class OtherTransactionErr(_UniffiTempTransactionError):

        def __init__(self):
            pass
        def __repr__(self):
            return "TransactionError.OtherTransactionErr({})".format(str(self))
    _UniffiTempTransactionError.OtherTransactionErr = OtherTransactionErr # type: ignore

TransactionError = _UniffiTempTransactionError # type: ignore
del _UniffiTempTransactionError


class _UniffiConverterTypeTransactionError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TransactionError.Io(
            )
        if variant == 2:
            return TransactionError.OversizedVectorAllocation(
            )
        if variant == 3:
            return TransactionError.InvalidChecksum(
                expected=_UniffiConverterString.read(buf),
                actual=_UniffiConverterString.read(buf),
            )
        if variant == 4:
            return TransactionError.NonMinimalVarInt(
            )
        if variant == 5:
            return TransactionError.ParseFailed(
            )
        if variant == 6:
            return TransactionError.UnsupportedSegwitFlag(
                flag=_UniffiConverterUInt8.read(buf),
            )
        if variant == 7:
            return TransactionError.OtherTransactionErr(
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, TransactionError.Io):
            return
        if isinstance(value, TransactionError.OversizedVectorAllocation):
            return
        if isinstance(value, TransactionError.InvalidChecksum):
            _UniffiConverterString.check_lower(value.expected)
            _UniffiConverterString.check_lower(value.actual)
            return
        if isinstance(value, TransactionError.NonMinimalVarInt):
            return
        if isinstance(value, TransactionError.ParseFailed):
            return
        if isinstance(value, TransactionError.UnsupportedSegwitFlag):
            _UniffiConverterUInt8.check_lower(value.flag)
            return
        if isinstance(value, TransactionError.OtherTransactionErr):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, TransactionError.Io):
            buf.write_i32(1)
        if isinstance(value, TransactionError.OversizedVectorAllocation):
            buf.write_i32(2)
        if isinstance(value, TransactionError.InvalidChecksum):
            buf.write_i32(3)
            _UniffiConverterString.write(value.expected, buf)
            _UniffiConverterString.write(value.actual, buf)
        if isinstance(value, TransactionError.NonMinimalVarInt):
            buf.write_i32(4)
        if isinstance(value, TransactionError.ParseFailed):
            buf.write_i32(5)
        if isinstance(value, TransactionError.UnsupportedSegwitFlag):
            buf.write_i32(6)
            _UniffiConverterUInt8.write(value.flag, buf)
        if isinstance(value, TransactionError.OtherTransactionErr):
            buf.write_i32(7)


# TxidParseError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class TxidParseError(Exception):
    pass

_UniffiTempTxidParseError = TxidParseError

class TxidParseError:  # type: ignore
    class InvalidTxid(_UniffiTempTxidParseError):

        def __init__(self, txid):
            super().__init__(", ".join([
                "txid={!r}".format(txid),
            ]))
            self.txid = txid
        def __repr__(self):
            return "TxidParseError.InvalidTxid({})".format(str(self))
    _UniffiTempTxidParseError.InvalidTxid = InvalidTxid # type: ignore

TxidParseError = _UniffiTempTxidParseError # type: ignore
del _UniffiTempTxidParseError


class _UniffiConverterTypeTxidParseError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TxidParseError.InvalidTxid(
                txid=_UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, TxidParseError.InvalidTxid):
            _UniffiConverterString.check_lower(value.txid)
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, TxidParseError.InvalidTxid):
            buf.write_i32(1)
            _UniffiConverterString.write(value.txid, buf)


# WalletCreationError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class WalletCreationError(Exception):
    pass

_UniffiTempWalletCreationError = WalletCreationError

class WalletCreationError:  # type: ignore
    class Io(_UniffiTempWalletCreationError):

        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message
        def __repr__(self):
            return "WalletCreationError.Io({})".format(str(self))
    _UniffiTempWalletCreationError.Io = Io # type: ignore
    class InvalidMagicBytes(_UniffiTempWalletCreationError):

        def __init__(self, got, expected):
            super().__init__(", ".join([
                "got={!r}".format(got),
                "expected={!r}".format(expected),
            ]))
            self.got = got
            self.expected = expected
        def __repr__(self):
            return "WalletCreationError.InvalidMagicBytes({})".format(str(self))
    _UniffiTempWalletCreationError.InvalidMagicBytes = InvalidMagicBytes # type: ignore
    class Descriptor(_UniffiTempWalletCreationError):

        def __init__(self):
            pass
        def __repr__(self):
            return "WalletCreationError.Descriptor({})".format(str(self))
    _UniffiTempWalletCreationError.Descriptor = Descriptor # type: ignore
    class Persist(_UniffiTempWalletCreationError):

        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message
        def __repr__(self):
            return "WalletCreationError.Persist({})".format(str(self))
    _UniffiTempWalletCreationError.Persist = Persist # type: ignore
    class NotInitialized(_UniffiTempWalletCreationError):

        def __init__(self):
            pass
        def __repr__(self):
            return "WalletCreationError.NotInitialized({})".format(str(self))
    _UniffiTempWalletCreationError.NotInitialized = NotInitialized # type: ignore
    class LoadedGenesisDoesNotMatch(_UniffiTempWalletCreationError):

        def __init__(self, expected, got):
            super().__init__(", ".join([
                "expected={!r}".format(expected),
                "got={!r}".format(got),
            ]))
            self.expected = expected
            self.got = got
        def __repr__(self):
            return "WalletCreationError.LoadedGenesisDoesNotMatch({})".format(str(self))
    _UniffiTempWalletCreationError.LoadedGenesisDoesNotMatch = LoadedGenesisDoesNotMatch # type: ignore
    class LoadedNetworkDoesNotMatch(_UniffiTempWalletCreationError):

        def __init__(self, expected, got):
            super().__init__(", ".join([
                "expected={!r}".format(expected),
                "got={!r}".format(got),
            ]))
            self.expected = expected
            self.got = got
        def __repr__(self):
            return "WalletCreationError.LoadedNetworkDoesNotMatch({})".format(str(self))
    _UniffiTempWalletCreationError.LoadedNetworkDoesNotMatch = LoadedNetworkDoesNotMatch # type: ignore
    class LoadedDescriptorDoesNotMatch(_UniffiTempWalletCreationError):

        def __init__(self, got, keychain):
            super().__init__(", ".join([
                "got={!r}".format(got),
                "keychain={!r}".format(keychain),
            ]))
            self.got = got
            self.keychain = keychain
        def __repr__(self):
            return "WalletCreationError.LoadedDescriptorDoesNotMatch({})".format(str(self))
    _UniffiTempWalletCreationError.LoadedDescriptorDoesNotMatch = LoadedDescriptorDoesNotMatch # type: ignore

WalletCreationError = _UniffiTempWalletCreationError # type: ignore
del _UniffiTempWalletCreationError


class _UniffiConverterTypeWalletCreationError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return WalletCreationError.Io(
                error_message=_UniffiConverterString.read(buf),
            )
        if variant == 2:
            return WalletCreationError.InvalidMagicBytes(
                got=_UniffiConverterSequenceUInt8.read(buf),
                expected=_UniffiConverterSequenceUInt8.read(buf),
            )
        if variant == 3:
            return WalletCreationError.Descriptor(
            )
        if variant == 4:
            return WalletCreationError.Persist(
                error_message=_UniffiConverterString.read(buf),
            )
        if variant == 5:
            return WalletCreationError.NotInitialized(
            )
        if variant == 6:
            return WalletCreationError.LoadedGenesisDoesNotMatch(
                expected=_UniffiConverterString.read(buf),
                got=_UniffiConverterString.read(buf),
            )
        if variant == 7:
            return WalletCreationError.LoadedNetworkDoesNotMatch(
                expected=_UniffiConverterTypeNetwork.read(buf),
                got=_UniffiConverterOptionalTypeNetwork.read(buf),
            )
        if variant == 8:
            return WalletCreationError.LoadedDescriptorDoesNotMatch(
                got=_UniffiConverterString.read(buf),
                keychain=_UniffiConverterTypeKeychainKind.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, WalletCreationError.Io):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, WalletCreationError.InvalidMagicBytes):
            _UniffiConverterSequenceUInt8.check_lower(value.got)
            _UniffiConverterSequenceUInt8.check_lower(value.expected)
            return
        if isinstance(value, WalletCreationError.Descriptor):
            return
        if isinstance(value, WalletCreationError.Persist):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, WalletCreationError.NotInitialized):
            return
        if isinstance(value, WalletCreationError.LoadedGenesisDoesNotMatch):
            _UniffiConverterString.check_lower(value.expected)
            _UniffiConverterString.check_lower(value.got)
            return
        if isinstance(value, WalletCreationError.LoadedNetworkDoesNotMatch):
            _UniffiConverterTypeNetwork.check_lower(value.expected)
            _UniffiConverterOptionalTypeNetwork.check_lower(value.got)
            return
        if isinstance(value, WalletCreationError.LoadedDescriptorDoesNotMatch):
            _UniffiConverterString.check_lower(value.got)
            _UniffiConverterTypeKeychainKind.check_lower(value.keychain)
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, WalletCreationError.Io):
            buf.write_i32(1)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, WalletCreationError.InvalidMagicBytes):
            buf.write_i32(2)
            _UniffiConverterSequenceUInt8.write(value.got, buf)
            _UniffiConverterSequenceUInt8.write(value.expected, buf)
        if isinstance(value, WalletCreationError.Descriptor):
            buf.write_i32(3)
        if isinstance(value, WalletCreationError.Persist):
            buf.write_i32(4)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, WalletCreationError.NotInitialized):
            buf.write_i32(5)
        if isinstance(value, WalletCreationError.LoadedGenesisDoesNotMatch):
            buf.write_i32(6)
            _UniffiConverterString.write(value.expected, buf)
            _UniffiConverterString.write(value.got, buf)
        if isinstance(value, WalletCreationError.LoadedNetworkDoesNotMatch):
            buf.write_i32(7)
            _UniffiConverterTypeNetwork.write(value.expected, buf)
            _UniffiConverterOptionalTypeNetwork.write(value.got, buf)
        if isinstance(value, WalletCreationError.LoadedDescriptorDoesNotMatch):
            buf.write_i32(8)
            _UniffiConverterString.write(value.got, buf)
            _UniffiConverterTypeKeychainKind.write(value.keychain, buf)





class WordCount(enum.Enum):
    WORDS12 = 0
    
    WORDS15 = 1
    
    WORDS18 = 2
    
    WORDS21 = 3
    
    WORDS24 = 4
    


class _UniffiConverterTypeWordCount(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return WordCount.WORDS12
        if variant == 2:
            return WordCount.WORDS15
        if variant == 3:
            return WordCount.WORDS18
        if variant == 4:
            return WordCount.WORDS21
        if variant == 5:
            return WordCount.WORDS24
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == WordCount.WORDS12:
            return
        if value == WordCount.WORDS15:
            return
        if value == WordCount.WORDS18:
            return
        if value == WordCount.WORDS21:
            return
        if value == WordCount.WORDS24:
            return

    @staticmethod
    def write(value, buf):
        if value == WordCount.WORDS12:
            buf.write_i32(1)
        if value == WordCount.WORDS15:
            buf.write_i32(2)
        if value == WordCount.WORDS18:
            buf.write_i32(3)
        if value == WordCount.WORDS21:
            buf.write_i32(4)
        if value == WordCount.WORDS24:
            buf.write_i32(5)





class _UniffiConverterOptionalString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeDescriptor(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeDescriptor.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeDescriptor.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeDescriptor.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeCanonicalTx(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeCanonicalTx.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeCanonicalTx.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeCanonicalTx.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeNetwork(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeNetwork.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeNetwork.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeNetwork.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterSequenceUInt8(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterUInt8.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterUInt8.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterUInt8.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeCanonicalTx(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeCanonicalTx.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeCanonicalTx.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeCanonicalTx.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeLocalOutput(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeLocalOutput.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeLocalOutput.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeLocalOutput.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeOutPoint(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeOutPoint.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeOutPoint.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeOutPoint.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeScriptAmount(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeScriptAmount.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeScriptAmount.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeScriptAmount.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeTxIn(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeTxIn.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeTxIn.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeTxIn.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeTxOut(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeTxOut.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeTxOut.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeTxOut.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceSequenceUInt8(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterSequenceUInt8.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterSequenceUInt8.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterSequenceUInt8.read(buf) for i in range(count)
        ]

__all__ = [
    "InternalError",
    "AddressError",
    "Bip32Error",
    "Bip39Error",
    "CalculateFeeError",
    "CannotConnectError",
    "ChainPosition",
    "ChangeSpendPolicy",
    "CreateTxError",
    "DescriptorError",
    "DescriptorKeyError",
    "ElectrumError",
    "EsploraError",
    "ExtractTxError",
    "FeeRateError",
    "KeychainKind",
    "Network",
    "ParseAmountError",
    "PersistenceError",
    "PsbtParseError",
    "SignerError",
    "TransactionError",
    "TxidParseError",
    "WalletCreationError",
    "WordCount",
    "AddressInfo",
    "Balance",
    "CanonicalTx",
    "LocalOutput",
    "OutPoint",
    "ScriptAmount",
    "SentAndReceivedValues",
    "TxIn",
    "TxOut",
    "Address",
    "Amount",
    "BumpFeeTxBuilder",
    "DerivationPath",
    "Descriptor",
    "DescriptorPublicKey",
    "DescriptorSecretKey",
    "ElectrumClient",
    "EsploraClient",
    "FeeRate",
    "FullScanRequest",
    "Mnemonic",
    "Psbt",
    "Script",
    "SyncRequest",
    "Transaction",
    "TxBuilder",
    "Update",
    "Wallet",
]

